
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="de">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Namen und Funktionen (der Rest der OCaml-Grammatik) &#8212; Einführung ins Programmieren 2022</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/extra-styles.css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Stichwortverzeichnis" href="../genindex.html" />
    <link rel="search" title="Suche" href="../search.html" />
    <link rel="next" title="Lehrmaterial für Woche 06" href="../week-06/week-06_index.html" />
    <link rel="prev" title="Lehrmaterial Woche-05" href="week-05-index.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Stichwortverzeichnis"
             accesskey="I">Index</a></li>
        <li class="right" >
          <a href="../week-06/week-06_index.html" title="Lehrmaterial für Woche 06"
             accesskey="N">weiter</a> |</li>
        <li class="right" >
          <a href="week-05-index.html" title="Lehrmaterial Woche-05"
             accesskey="P">zurück</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Einführung ins Programmieren 2022</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="week-05-index.html" accesskey="U">Lehrmaterial Woche-05</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="namen-und-funktionen-der-rest-der-ocaml-grammatik">
<h1>Namen und Funktionen (der Rest der OCaml-Grammatik)<a class="headerlink" href="#namen-und-funktionen-der-rest-der-ocaml-grammatik" title="Link zu dieser Überschrift">¶</a></h1>
<p>In diesem Teil des Lehrmaterials lernen wir endlich das, was unsere Programme
interessant macht.</p>
<div class="section" id="namen-und-typenumgebungen">
<h2>Namen und Typenumgebungen<a class="headerlink" href="#namen-und-typenumgebungen" title="Link zu dieser Überschrift">¶</a></h2>
<p>OCaml gibt uns die Möglichkeit, Namen festzulegen. Diese Namen werden oftmals auch
als „Identifikatoren“ oder „Variablen“ bezeichnet und ihre Typen werden in der
Typenumgebung gespeichert:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;type_environment&gt; ::= . | ( &lt;name&gt; : &lt;type&gt;), &lt;type_environment&gt;

&lt;type&gt;             ::= int | bool | char | string | &lt;type&gt; * ... * &lt;type&gt; | unit

&lt;expression&gt;       ::= &lt;integer&gt;
                     | &lt;boolean&gt;
                     | &lt;character&gt;
                     | &lt;string&gt;
                     | if &lt;expression&gt; then &lt;expression&gt; else &lt;expression&gt;
                     | (&lt;expression&gt;, ..., &lt;expression&gt;)
                     | &lt;name&gt;

&lt;integer&gt;          ::= 0 | -1 | 1 | -2 | 2 | -3 | 3 | ...

&lt;boolean&gt;          ::= true | false

&lt;character&gt;        ::= &#39;a&#39; | &#39;b&#39; | &#39;c&#39;| ...

&lt;string&gt;           ::= &quot;&quot; | &quot;A&quot; | &quot;hello world&quot; | &quot;42&quot; | ...

&lt;name&gt;             ::= eine Folge von Zeichen, angefangen mit einem Kleinbuchstaben
</pre></div>
</div>
<p>Die Typenumgebung enthält eine Sammlung von Bindungen zwischen Namen und den
entsprechenden Typen. Es ist aufgebaut wie die sprichwörtliche Zwiebel: Innen ist ein
Keim und darum liegt eine Schicht nach der anderen:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">.</span></code> repräsentiert eine leere Typenumgebung; und</li>
<li>nehmen wir einen Namen <code class="docutils literal notranslate"><span class="pre">x</span></code>, einen Typen <code class="docutils literal notranslate"><span class="pre">t</span></code> und eine Typenumgebung <code class="docutils literal notranslate"><span class="pre">G</span></code>, dann
repräsentiert <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">:</span> <span class="pre">t),</span> <span class="pre">G</span></code> die Erweiterung der Typenumgebung <code class="docutils literal notranslate"><span class="pre">G</span></code> um die Bindung
von <code class="docutils literal notranslate"><span class="pre">x</span></code> zum Typen <code class="docutils literal notranslate"><span class="pre">t</span></code>.</li>
</ul>
<p>Also zum Beispiel:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">.</span></code> ist die leere Typenumgebung, die keine Bindungen zwischen Namen und Typen
enthält.</li>
<li><code class="docutils literal notranslate"><span class="pre">(c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.</span></code> erweitert die vorige Typenumgebung mit der Bindung des Namens
<code class="docutils literal notranslate"><span class="pre">c</span></code> zum Typen <code class="docutils literal notranslate"><span class="pre">char</span></code>. In dieser Typenumgebung hat also <code class="docutils literal notranslate"><span class="pre">c</span></code> den Typen
<code class="docutils literal notranslate"><span class="pre">char</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">(b</span> <span class="pre">:</span> <span class="pre">bool),</span> <span class="pre">((c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.)</span></code> erweitert die vorige Typenumgebung um die Bindung
des Namens <code class="docutils literal notranslate"><span class="pre">b</span></code> zum Typen <code class="docutils literal notranslate"><span class="pre">bool</span></code>. Hier hat also der Name <code class="docutils literal notranslate"><span class="pre">c</span></code> den Typen
<code class="docutils literal notranslate"><span class="pre">char</span></code> und der Name <code class="docutils literal notranslate"><span class="pre">b</span></code> den Typen <code class="docutils literal notranslate"><span class="pre">bool</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">(i</span> <span class="pre">:</span> <span class="pre">int),</span> <span class="pre">((b:</span> <span class="pre">bool),</span> <span class="pre">((c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.))</span></code> erweitert die vorige Typenumgebung um
die Bindung des Namens <code class="docutils literal notranslate"><span class="pre">i</span></code> zum Typen <code class="docutils literal notranslate"><span class="pre">int</span></code>. Hier hat also der Name <code class="docutils literal notranslate"><span class="pre">i</span></code> den
Typen <code class="docutils literal notranslate"><span class="pre">int</span></code>, der Name <code class="docutils literal notranslate"><span class="pre">b</span></code> den Typen <code class="docutils literal notranslate"><span class="pre">bool</span></code> und der Name <code class="docutils literal notranslate"><span class="pre">c</span></code> den Typen
<code class="docutils literal notranslate"><span class="pre">char</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">(b</span> <span class="pre">:</span> <span class="pre">string),</span> <span class="pre">((i</span> <span class="pre">:</span> <span class="pre">int),</span> <span class="pre">((b</span> <span class="pre">:</span> <span class="pre">bool),</span> <span class="pre">((c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.)))</span></code> erweitert die vorige
Typenumgebung um die Bindung des Namens <code class="docutils literal notranslate"><span class="pre">b</span></code> zum Typen <code class="docutils literal notranslate"><span class="pre">string</span></code>. Hier hat der
Name <code class="docutils literal notranslate"><span class="pre">b</span></code> den Typen <code class="docutils literal notranslate"><span class="pre">string</span></code>, der Name <code class="docutils literal notranslate"><span class="pre">i</span></code> den Typen <code class="docutils literal notranslate"><span class="pre">int</span></code> und der Name
<code class="docutils literal notranslate"><span class="pre">c</span></code> de Typen <code class="docutils literal notranslate"><span class="pre">char</span></code>.</li>
</ul>
<p>Die Frage stellt sich nun, warum in der letzten Typenumgebung der Name <code class="docutils literal notranslate"><span class="pre">b</span></code> den
Typen <code class="docutils literal notranslate"><span class="pre">string</span></code> hat und nicht den Typen <code class="docutils literal notranslate"><span class="pre">bool</span></code>. Das liegt daran, dass die
Typeumgebung von außen nach innen gelesen wird und die neueste Bindung diejenige ist,
die zählt. Die Bindung von <code class="docutils literal notranslate"><span class="pre">(b</span> <span class="pre">:</span> <span class="pre">string)</span></code> „überschattet“ („shadows“) also die
ältere Bindung von <code class="docutils literal notranslate"><span class="pre">(b</span> <span class="pre">:</span> <span class="pre">bool)</span></code>.</p>
<p>Der Infix-Konstruktor <code class="docutils literal notranslate"><span class="pre">,</span></code> ist rechts-assoziativ, weshalb wir die Klammern rechts
vom <code class="docutils literal notranslate"><span class="pre">,</span></code> auch weg lassen können:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">(b</span> <span class="pre">:</span> <span class="pre">bool),</span> <span class="pre">(c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.</span></code> ist kurz für <code class="docutils literal notranslate"><span class="pre">(b</span> <span class="pre">:</span> <span class="pre">bool),</span> <span class="pre">((c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.)</span></code>,</li>
<li><code class="docutils literal notranslate"><span class="pre">(i</span> <span class="pre">:</span> <span class="pre">int),</span> <span class="pre">(b</span> <span class="pre">:</span> <span class="pre">bool),</span> <span class="pre">(c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.</span></code> ist kurz für <code class="docutils literal notranslate"><span class="pre">(i</span> <span class="pre">:</span> <span class="pre">int),</span> <span class="pre">((b</span> <span class="pre">:</span> <span class="pre">bool),</span> <span class="pre">((c</span>
<span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.))</span></code>, usw.</li>
</ul>
<p>Das Überschatten wird klarer, wenn wir uns die Typenregeln anschauen, die das
Nachschlagen (lookup) in der Typenumgebung beschreiben.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>LOOKUP_FOUND -------------------
             (x : t), G |- x : t

                        G |- x : t
LOOKUP_NOT_FOUND_YET ----------------------- wo x und x&#39; verschieden sind.
                     (x&#39; : t&#39;), G |- x : t
</pre></div>
</div>
<p>In Worten:</p>
<ul class="simple">
<li>für einen beliebigen Namen <code class="docutils literal notranslate"><span class="pre">x</span></code>, einen beliebigen Typen <code class="docutils literal notranslate"><span class="pre">t</span></code> und eine beliebige
Typenumgebung <code class="docutils literal notranslate"><span class="pre">G</span></code> hat <code class="docutils literal notranslate"><span class="pre">x</span></code> den Typen <code class="docutils literal notranslate"><span class="pre">t</span></code> in der Typenumgebung <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">:</span> <span class="pre">t),</span> <span class="pre">G</span></code>;
und</li>
<li>für eine beliebige Typenumgebung <code class="docutils literal notranslate"><span class="pre">G</span></code>, einen beliebigen Namen <code class="docutils literal notranslate"><span class="pre">x</span></code>, einen
beliebigen Typen <code class="docutils literal notranslate"><span class="pre">t</span></code>, einen beliebigen Namen <code class="docutils literal notranslate"><span class="pre">x'</span></code>, der nicht der gleiche ist
wie <code class="docutils literal notranslate"><span class="pre">x</span></code> und einen beliebigen Typen <code class="docutils literal notranslate"><span class="pre">t'</span></code>: Wenn <code class="docutils literal notranslate"><span class="pre">x</span></code> in der Typenumgebung <code class="docutils literal notranslate"><span class="pre">G</span></code>
den Typen <code class="docutils literal notranslate"><span class="pre">t</span></code> hat, dann hat es denselben Typen <code class="docutils literal notranslate"><span class="pre">t</span></code>, wenn <code class="docutils literal notranslate"><span class="pre">G</span></code> durch die
Bindung <code class="docutils literal notranslate"><span class="pre">x'</span> <span class="pre">:</span> <span class="pre">t'</span></code> erweitert wird.</li>
</ul>
<p>In anderen Worten:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">x</span></code> hat immer den Typen <code class="docutils literal notranslate"><span class="pre">t</span></code> in einer Typenumgebung, die mit <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">:</span> <span class="pre">t)</span></code>
anfängt;</li>
<li><code class="docutils literal notranslate"><span class="pre">x</span></code> hat den Typen <code class="docutils literal notranslate"><span class="pre">t</span></code> in einer Typenumgebung, die mit <code class="docutils literal notranslate"><span class="pre">(x'</span> <span class="pre">:</span> <span class="pre">t')</span></code> anfängt und
mit <code class="docutils literal notranslate"><span class="pre">G</span></code> fortsetzt, wannimmer <code class="docutils literal notranslate"><span class="pre">x'</span></code> und <code class="docutils literal notranslate"><span class="pre">x</span></code> unterschiedliche Namen sind und
<code class="docutils literal notranslate"><span class="pre">x</span></code> in der Typenumgebung <code class="docutils literal notranslate"><span class="pre">G</span></code> den Typen <code class="docutils literal notranslate"><span class="pre">t</span></code> hat.</li>
</ul>
<p>Wir benutzen diese Regeln um Namen in einer Typenumgebung nachzuschlagen. Also zum
Beispiel:</p>
<ol class="loweralpha simple">
<li>einen beliebigen Namen in der leeren Typenumgebung <code class="docutils literal notranslate"><span class="pre">.</span></code> nachzuschlagen ist
undefiniert (und ruft einen Fehler hervor),</li>
<li><code class="docutils literal notranslate"><span class="pre">i</span></code> in der Typenumgebung <code class="docutils literal notranslate"><span class="pre">(i</span> <span class="pre">:</span> <span class="pre">int),</span> <span class="pre">(b</span> <span class="pre">:</span> <span class="pre">bool),</span> <span class="pre">(c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.</span></code> nachzuschlagen
ergibt <code class="docutils literal notranslate"><span class="pre">int</span></code>,</li>
<li><code class="docutils literal notranslate"><span class="pre">b</span></code> in der Typenumgebung <code class="docutils literal notranslate"><span class="pre">(i</span> <span class="pre">:</span> <span class="pre">int),</span> <span class="pre">(b</span> <span class="pre">:</span> <span class="pre">bool),</span> <span class="pre">(c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.</span></code> nachzuschlagen
ergibt <code class="docutils literal notranslate"><span class="pre">bool</span></code>,</li>
<li><code class="docutils literal notranslate"><span class="pre">c</span></code> in der Typenumgebung <code class="docutils literal notranslate"><span class="pre">(i</span> <span class="pre">:</span> <span class="pre">int),</span> <span class="pre">(b</span> <span class="pre">:</span> <span class="pre">bool),</span> <span class="pre">(c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.</span></code> nachzuschlagen
ergibt <code class="docutils literal notranslate"><span class="pre">char</span></code>,</li>
<li><code class="docutils literal notranslate"><span class="pre">x</span></code> in der Typenumgebung <code class="docutils literal notranslate"><span class="pre">(i</span> <span class="pre">:</span> <span class="pre">int),</span> <span class="pre">(b</span> <span class="pre">:</span> <span class="pre">bool),</span> <span class="pre">(c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.</span></code> nachzuschlagen
ist undefiniert und ruft einen Fehler hervor,</li>
<li><code class="docutils literal notranslate"><span class="pre">x</span></code> in der Typenumgebung <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">:</span> <span class="pre">int),</span> <span class="pre">(x</span> <span class="pre">:</span> <span class="pre">bool),</span> <span class="pre">(x</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.</span></code> nachzuschlagen
ergibt <code class="docutils literal notranslate"><span class="pre">int</span></code>.</li>
</ol>
<p>Im letzten Fall überschattet die letzte Bindung von <code class="docutils literal notranslate"><span class="pre">x</span></code> die beiden vorigen
Bindungen.</p>
</div>
<div class="section" id="ubung-25">
<h2>Übung 25<a class="headerlink" href="#ubung-25" title="Link zu dieser Überschrift">¶</a></h2>
<p>Überzeuge dich von den obigen Beispielen indem du die jeweiligen Beweisbäume
aufzeichnest.</p>
</div>
<div class="section" id="teilweise-losung-fur-ubung-25">
<h2>Teilweise Lösung für Übung 25<a class="headerlink" href="#teilweise-losung-fur-ubung-25" title="Link zu dieser Überschrift">¶</a></h2>
<ol class="loweralpha">
<li><p class="first">Nehmen wir den Namen <code class="docutils literal notranslate"><span class="pre">x</span></code> und versuchen wir, diesen Namen in der leeren
Typenumgebung <code class="docutils literal notranslate"><span class="pre">.</span></code> nachzuschlagen. Die Wurzel des Baumes ist folglich:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>. |- x : ehm
</pre></div>
</div>
<p>für einen bisher noch unbekannten Typen <code class="docutils literal notranslate"><span class="pre">ehm</span></code>.</p>
<p>Wir könenn weder die Regel <code class="docutils literal notranslate"><span class="pre">LOOKUP_FOUND</span></code> noch die Regel
<code class="docutils literal notranslate"><span class="pre">LOOKUP_NOT_FOUND_YET</span></code> anwenden. Also können wir keinen Beweisbaum konstruieren
und somit auch keinen Typen für <code class="docutils literal notranslate"><span class="pre">x</span></code> finden. Der Typ von <code class="docutils literal notranslate"><span class="pre">x</span></code> ist also
undefiniert.</p>
</li>
<li><p class="first">Versuchen wir <code class="docutils literal notranslate"><span class="pre">i</span></code> in der Typenumgebung <code class="docutils literal notranslate"><span class="pre">(i</span> <span class="pre">:</span> <span class="pre">int),</span> <span class="pre">(b</span> <span class="pre">:</span> <span class="pre">bool),</span> <span class="pre">(c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.</span></code>
nachzuschlagen. Die Wurzel des Baumes lautet:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(i : int), (b : bool), (c : char), . |- i : ehm
</pre></div>
</div>
<p>für einen bisher unbekannten Typen <code class="docutils literal notranslate"><span class="pre">ehm</span></code>.</p>
<p>Wir können (nur) die Regel <code class="docutils literal notranslate"><span class="pre">LOOKUP_FOUND</span></code> verwenden, wo <code class="docutils literal notranslate"><span class="pre">x</span></code> mit <code class="docutils literal notranslate"><span class="pre">i</span></code> ersetzt
wird, <code class="docutils literal notranslate"><span class="pre">t</span></code> mit <code class="docutils literal notranslate"><span class="pre">int</span></code>, und <code class="docutils literal notranslate"><span class="pre">G</span></code> mit <code class="docutils literal notranslate"><span class="pre">(b</span> <span class="pre">:</span> <span class="pre">bool),</span> <span class="pre">(c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.</span></code>. Auf der
rechten Seite des <code class="docutils literal notranslate"><span class="pre">|-</span></code> ersetzen wir wieder <code class="docutils literal notranslate"><span class="pre">x</span></code> mit <code class="docutils literal notranslate"><span class="pre">i</span></code> und <code class="docutils literal notranslate"><span class="pre">t</span></code> mit
<code class="docutils literal notranslate"><span class="pre">ehm</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>LOOKUP_FOUND -------------------------------------------------
              (i : int), (b : bool), (c : char), . |- i : ehm
</pre></div>
</div>
<p>Da in diesem Beweisbaum <code class="docutils literal notranslate"><span class="pre">t</span></code> einmal mit <code class="docutils literal notranslate"><span class="pre">int</span></code> und einmal mit <code class="docutils literal notranslate"><span class="pre">ehm</span></code> ersetzt
ist, haben wir nun herausgefunden, dass der bisher unbekannte Typ <code class="docutils literal notranslate"><span class="pre">ehm</span></code> in
Wirklichkeit <code class="docutils literal notranslate"><span class="pre">int</span></code> sein muss. Der fertige Beweisbaum lautet also:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>LOOKUP_FOUND -------------------------------------------------
               (i : int), (b : bool), (c : char), . |- i : int
</pre></div>
</div>
<p>Die Existenz dieses Baumes Beweist, dass in der Typenumgebung <code class="docutils literal notranslate"><span class="pre">(i</span> <span class="pre">:</span> <span class="pre">int),</span> <span class="pre">(b</span> <span class="pre">:</span>
<span class="pre">bool),</span> <span class="pre">(c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.</span></code> das Nachschlagen des Namens <code class="docutils literal notranslate"><span class="pre">i</span></code> den Typen <code class="docutils literal notranslate"><span class="pre">int</span></code>
ergibt.</p>
</li>
<li><p class="first">Versuchen wir <code class="docutils literal notranslate"><span class="pre">b</span></code> in der Typenumgebung <code class="docutils literal notranslate"><span class="pre">(i</span> <span class="pre">:</span> <span class="pre">int),</span> <span class="pre">(b</span> <span class="pre">:</span> <span class="pre">bool),</span> <span class="pre">(c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.</span></code>
nachzuschlagen. Die Wurzel des Baumes lautet:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(i : int), (b : bool), (c : char), . |- b : ehm
</pre></div>
</div>
<p>für einen bisher unbekannten Typen <code class="docutils literal notranslate"><span class="pre">ehm</span></code>.</p>
<p>Wir können hier (nur) die Regel <code class="docutils literal notranslate"><span class="pre">LOOKUP_NOT_FOUND_YET</span></code> anwenden, wo <code class="docutils literal notranslate"><span class="pre">x'</span></code> mit
<code class="docutils literal notranslate"><span class="pre">i</span></code> ersetzt wird, <code class="docutils literal notranslate"><span class="pre">t'</span></code> mit <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">G</span></code> mit <code class="docutils literal notranslate"><span class="pre">(b</span> <span class="pre">:</span> <span class="pre">bool),</span> <span class="pre">(c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.</span></code>,
<code class="docutils literal notranslate"><span class="pre">x</span></code> mit <code class="docutils literal notranslate"><span class="pre">b</span></code> und <code class="docutils literal notranslate"><span class="pre">t</span></code> mit <code class="docutils literal notranslate"><span class="pre">ehm</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>                     (b : bool), (c : char), . |- b : ehm
LOOKUP_NOT_FOUND_YET -----------------------------------------------
                     (i : int), (b : bool), (c : char), . |- b : ehm
</pre></div>
</div>
<p>Nun können wir (nur) die Regel <code class="docutils literal notranslate"><span class="pre">LOOKUP_FOUND</span></code> anwenden, wo <code class="docutils literal notranslate"><span class="pre">x</span></code> mit <code class="docutils literal notranslate"><span class="pre">b</span></code>
ersetzt wird, <code class="docutils literal notranslate"><span class="pre">t</span></code> mit <code class="docutils literal notranslate"><span class="pre">bool</span></code>, <code class="docutils literal notranslate"><span class="pre">G</span></code> mit <code class="docutils literal notranslate"><span class="pre">(c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code> mit <code class="docutils literal notranslate"><span class="pre">b</span></code> und
<code class="docutils literal notranslate"><span class="pre">t</span></code> mit <code class="docutils literal notranslate"><span class="pre">ehm</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>        LOOKUP_FOUND ------------------------------------
                     (b : bool), (c : char), . |- b : ehm
LOOKUP_NOT_FOUND_YET -----------------------------------------------
                     (i : int), (b : bool), (c : char), . |- b : ehm
</pre></div>
</div>
<p>Da wir in der Anwendung von <code class="docutils literal notranslate"><span class="pre">LOOKUP_FOUND</span></code> <code class="docutils literal notranslate"><span class="pre">t</span></code> im einen Fall mit <code class="docutils literal notranslate"><span class="pre">bool</span></code> und
im anderen Fall mit <code class="docutils literal notranslate"><span class="pre">ehm</span></code> ersetzt haben, wissen wir nun, dass der bisher
unbekannte Typ <code class="docutils literal notranslate"><span class="pre">ehm</span></code> <code class="docutils literal notranslate"><span class="pre">bool</span></code> sein muss.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>        LOOKUP_FOUND ------------------------------------
                     (b : bool), (c : char), . |- b : bool
LOOKUP_NOT_FOUND_YET -----------------------------------------------
                     (i : int), (b : bool), (c : char), . |- b : bool
</pre></div>
</div>
<p>Die Existenz dieses Baumes Beweist, dass in der Typenumgebung <code class="docutils literal notranslate"><span class="pre">(i</span> <span class="pre">:</span> <span class="pre">int),</span> <span class="pre">(b</span> <span class="pre">:</span>
<span class="pre">bool),</span> <span class="pre">(c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.</span></code> das Nachschlagen des Namens <code class="docutils literal notranslate"><span class="pre">b</span></code> den Typen <code class="docutils literal notranslate"><span class="pre">bool</span></code>
ergibt.</p>
</li>
</ol>
<p>d.-f. Konstruiere diese Bäume selbst.</p>
</div>
<div class="section" id="zwischenspiel-uber-umgebungen-und-zwiebeln">
<h2>Zwischenspiel über Umgebungen und Zwiebeln<a class="headerlink" href="#zwischenspiel-uber-umgebungen-und-zwiebeln" title="Link zu dieser Überschrift">¶</a></h2>
<p><strong>Alfrothul:</strong> Erklär mir bitte nochmal, warum jetzt eine Umgebung aufgebaut ist wie
eine Zwiebel…?</p>
<p><strong>Brynja:</strong> Eigentlich ganz logisch. Eine Zwiebel können wir auch beschreiben wie
eine Umgebung:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;zwiebel&gt;  ::= ^ | (&lt;zwiebel&gt;)

&lt;umgebung&gt; ::= . |(&lt;name&gt; : &lt;typ&gt;), &lt;umgebung&gt;
</pre></div>
</div>
<p>Eine leere Umgebung ist wie der Keim, <code class="docutils literal notranslate"><span class="pre">^</span></code> in der Mitte einer Zwiebel: es ist nichts weiter
innen drin. Und wenn wir eine Zwiebel haben, können wir eine neue Zwiebel
konstruieren indem wir noch eine Lage drum herum wachsen lassen. Ich habe mir hier
die Freiheit genommen, jede Schicht mit einem Paar Klammern zu zeigen; sieht ja auch
aus wie eine Zwiebel. Also wir haben eine Zwiebel, zum Beispiel <code class="docutils literal notranslate"><span class="pre">(((^)))</span></code> und
können dann eine neue machen: <code class="docutils literal notranslate"><span class="pre">((((^))))</span></code></p>
<p>Ebenso konstruieren wir eine neue Umgebung indem wir eine bereits vorhandene nehmen
und noch eine Bindung hinzufügen. Also wenn wir die Umgebung <code class="docutils literal notranslate"><span class="pre">G</span></code> haben, können wir
eine neue machen, indem wir die Bindung von <code class="docutils literal notranslate"><span class="pre">x</span></code> zum Typen <code class="docutils literal notranslate"><span class="pre">t</span></code> hinzufügen: <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">:</span>
<span class="pre">t),</span> <span class="pre">G</span></code>.</p>
<p><strong>Alfrothul:</strong> Ok…</p>
<p><strong>Brynja:</strong> Jetzt stell dir vor, dass auf jede Schicht der Zwiebel ein Name gedruckt
ist.</p>
<p><strong>Alfrothul:</strong> Ok?</p>
<p><strong>Brynja:</strong> Jetzt gebe ich dir eine Zwiebel und frage dich, ob dein name auf eine der
Schichten gedruckt ist. Was musst du tun um diese Frage zu beantworten?</p>
<p><strong>Alfrothul:</strong> Ich schätze, ich muss die Schichten von der Zwiebel eine nach der
anderen abpulen und drauf gucken.</p>
<p><strong>Brynja:</strong> Genau. Und was, wenn du keine Schichten mehr hast, sondern nur den Keim?</p>
<p><strong>Alfrothul:</strong> Dann weiß ich, dass mein Name auf keiner der Schichten gestanden hat.</p>
<p><strong>Brynja:</strong> Eben. Wie in der leeren Umgebung.</p>
<p><strong>Sigrid (von der Seite):</strong> Und was, wenn die Zwiebel unendlich ist?</p>
<p><strong>Alfrothul:</strong> Unendlich? Das wüsste ich aber, wenn es so eine Zwiebel gibt.</p>
<p><strong>Brynja:</strong> Das kann sie auch gar nicht sein, sie ist schließlich konstruiert
worden. Beziehungsweise, wenn wir von der Metapher absehen, dann ist sie
gewachsen. Von innen nach außen. Das heißt, irgendwann müssen wir zum Keim kommen.</p>
<p><strong>Sigrid:</strong> Hm… und das gilt auch für Umgebungen, nehme ich an?</p>
<p><strong>Brynja:</strong> Ja, genau. Jedes mal wenn wir einen neuen Namen binden, erweitern wir die
Umgebung um eine Schicht. Und weil wir wissen, dass wir kein unendliches Programm
geschrieben haben, wissen wir auch, dass die Umgebung nicht unendlich sein kann.</p>
<p><strong>Alfrothul:</strong> Ich glaube, jetzt habe ich es kapiert. Aber wie machen wir das denn
überhaupt mit dem binden? Wir haben doch bisher nur gesehen, dass wir Namen schreiben
können, aber nicht wie wir Namen in OCaml binden können.</p>
<p><strong>Brynja:</strong> Vielleicht können wir das ja gar nicht…? Vielleicht haben wir nur die
schon definierten Namen?</p>
<p><strong>Sigrid:</strong> Schon definierte Namen?</p>
<p><strong>Brynja:</strong> Ja. Erinnert ihr euch noch an Woche-01 wo wir über <code class="docutils literal notranslate"><span class="pre">min_int</span></code> und
<code class="docutils literal notranslate"><span class="pre">max_int</span></code> gelernt haben?</p>
<p><strong>Sigrid und Alfrothul:</strong> Ja…?</p>
<p><strong>Brynja:</strong> Das müssen doch Namen sein. Die passen jedenfalls zu keinem anderen
Ausdruck, den wir bisher gelernt haben.</p>
<p><strong>Mimer:</strong> Stimmt genau. Und diese vordefinierten Namen können uns noch etwas anderes
zeigen. Ihr habt ja schon Typenumgebungen gesehen, aber zu jedem Namen gehört ja auch
ein Wert. Es gibt also auch Wertumgebungen. Die funktionieren genau so wie die
Typenumgebungen, nur dass sie für jeden Namen einen Wert speichern statt eines
Typen.</p>
<p><strong>Brynja:</strong> Das heißt irgendwo in OCaml ist eine Wertumgebung schon definiert, und
auf einer der Schichten steht:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(min_int : -4611686018427387904), (max_int : 4611686018427387903), G
</pre></div>
</div>
<p>wenn wir die restliche Werteumgebung <code class="docutils literal notranslate"><span class="pre">G</span></code> nennen.</p>
<p><strong>Mimer:</strong> Gut erkannt. Wir würden in diesem Fall wohl eher ein <code class="docutils literal notranslate"><span class="pre">=</span></code> benutzen statt
eines <code class="docutils literal notranslate"><span class="pre">:</span></code>, aber das Prinzip ist das gleiche.</p>
<p><strong>Alfrothul:</strong> Also <code class="docutils literal notranslate"><span class="pre">=</span></code> für Werte und <code class="docutils literal notranslate"><span class="pre">:</span></code> für Typen?</p>
<p><strong>Mimer:</strong> Genau.</p>
<p><strong>Sigrid:</strong> Aber was ist denn jetzt mit der Frage von vorhin? Können wir neue Namen
definieren? Und wenn ja, wie?</p>
<p><strong>Mimer:</strong> Einfach weiterlesen. Das kommt im nächsten Abschnitt.</p>
<blockquote class="epigraph">
<div><div class="line-block">
<div class="line">Pile on many more layers</div>
<div class="line">and I’ll be joining you there.</div>
</div>
<p class="attribution">&mdash;<a class="reference external" href="https://en.wikipedia.org/wiki/Shine_On_You_Crazy_Diamond">Pink Floyd</a></p>
</div></blockquote>
</div>
<div class="section" id="globale-variablen-deklarieren">
<h2>Globale Variablen deklarieren<a class="headerlink" href="#globale-variablen-deklarieren" title="Link zu dieser Überschrift">¶</a></h2>
<p>Natürlich sind Namen nicht sehr hilfreich, wenn man keine neuen definieren kann. In
OCaml haben wir die Möglichkeit, namen im Toplevel zu deklarieren und das Ergebnis
des Evaluierens eines Ausdruckes sowie den dazugehörigen Typen zu diesem Namen zu
binden:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;toplevel-expression&gt; ::= &lt;expression&gt;
                        | let &lt;formal&gt; = &lt;definiens&gt;

&lt;formal&gt;              ::= &lt;name&gt;

&lt;definiens&gt;           ::= &lt;expression&gt;
</pre></div>
</div>
<p>Das Binden einer Variablen erweitert OCamls Typenumgebung und Werteumgebung; nach dem
Binden können wir in folgenden Interaktionen mit der Toplevel-Loop auf die Variable
zugreifen. Wenn wir das tun, schlägt OCaml in seinen Umgebungen nach um den Typen und
den Wert zu finden.</p>
<p>Nehmen wir einen frisch gestarteten OCaml-Prozess.</p>
<ul>
<li><p class="first">zuerst bedeutet <code class="docutils literal notranslate"><span class="pre">x</span></code> gar nichts:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># x;;
Error: Unbound value x
#
</pre></div>
</div>
<p>daher findet OCaml auch nichts, wenn es in seiner ursprünglichen Typenumgebung
(nennen wir sie <code class="docutils literal notranslate"><span class="pre">Gt</span></code>) und Werteumgebung (<code class="docutils literal notranslate"><span class="pre">Gw</span></code>) nachschaut und druckt einen
Fehler;</p>
</li>
<li><p class="first">also binden wir <code class="docutils literal notranslate"><span class="pre">x</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># let x = 42;;
val x : int = 42
#
</pre></div>
</div>
<p>Wer aufgepasst hat, kann sich die neuen Umgebungen herleiten. Die Typenumgebung ist
nun <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">:</span> <span class="pre">int),</span> <span class="pre">Gt</span></code> und die Werteumgebung ist <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">:</span> <span class="pre">42),</span> <span class="pre">Gw</span></code>.</p>
</li>
<li><p class="first">Jetzt können wir <code class="docutils literal notranslate"><span class="pre">x</span></code> benutzen um den unter diesem Namen gespeicherten Wert zurück
zu bekommen:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># x;;
- : int = 42
#
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="ubung-26">
<h2>Übung 26<a class="headerlink" href="#ubung-26" title="Link zu dieser Überschrift">¶</a></h2>
<p>Führe die obige Interaktion in OCaml durch.</p>
<p>Danach gib die folgenden Schritte in OCaml ein:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">100;;</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">&quot;abracadabra&quot;;;</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">say</span> <span class="pre">=</span> <span class="pre">if</span> <span class="pre">1</span> <span class="pre">then</span> <span class="pre">&quot;what&quot;</span> <span class="pre">else</span> <span class="pre">&quot;?&quot;</span></code></li>
</ul>
<p>Schriebe für jeden Schritt auf, wie sich die Typenumgebung und die Werteumgebung
danach verändern.</p>
<p>Der letzte Schritt ruft einen Fehler hervor; finde heraus, ob die Variable <code class="docutils literal notranslate"><span class="pre">say</span></code>
trotzdem definiert wurde. Warum glaubst du, ist das der Fall?</p>
</div>
<div class="section" id="mehrere-globale-variablen-auf-einmal-deklarieren">
<h2>Mehrere globale Variablen auf einmal deklarieren<a class="headerlink" href="#mehrere-globale-variablen-auf-einmal-deklarieren" title="Link zu dieser Überschrift">¶</a></h2>
<p>Wir haben in OCaml auch die Möglichkeit mehrere (verschiedene) Variablen in einer
einzigen Eingabe zu binden. Die Grammatik dafür ist folgende:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;toplevel-expression&gt; ::= &lt;expression&gt;
                     | let &lt;formal&gt; = &lt;definiens&gt; {and &lt;formal&gt; = &lt;definiens&gt;}*
</pre></div>
</div>
<p>wo <code class="docutils literal notranslate"><span class="pre">{}*</span></code> bedeutet: wiederhole das in den Klammern gedruckte eine beliebige Anzahl
Male (null Mal ist auch zulässig).</p>
<p>Zum Beispiel:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># let x = 10 and y = 100;;
val x : int = 10
val y : int = 100
#
</pre></div>
</div>
<p>Das macht es uns leicht, die Werte von <code class="docutils literal notranslate"><span class="pre">x</span></code> und <code class="docutils literal notranslate"><span class="pre">y</span></code> zu tauschen:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># let x = y and y = x;;
val x : int = 100
val y : int = 10
#
</pre></div>
</div>
<p>(Gedankenfutter: Wie würden wir die Werte umtauschen, wenn wir nicht mehrere
Variablen zugleich binden könnten? Probiere deine Theorie gerne in OCaml aus.)</p>
<p>Wenn wir aber versuchen in einer Interaktion die gleiche Variable zweimal zu
deklarieren, wirft uns OCaml einen Fehler an den Kopf:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># let same = true and same = false;;
Error: Variable same is bound several times in this matching
#
</pre></div>
</div>
<p>Das ergibt auch Sinn. Die eine Bindung würde die andere schließlich überschatten und
da wir nicht auf halber Strecke durch diesen Befehl den ersten Wert benutzen können,
zwingt uns OCaml uns für einen Wert zu entscheiden.</p>
<p>(Gedankenfutter: Mit dieser Einschränkung, dass eine Variable nicht im selben Befehl
mehrmals gebunden werden kann, ist es wichtig in welcher Reihenfolge die Umgebungen
erweitert werden?)</p>
</div>
<div class="section" id="zwischenspiel-uber-die-wichtigkeit-der-reihenfolge-losung-zum-gedankenfutter">
<h2>Zwischenspiel über die Wichtigkeit der Reihenfolge (Lösung zum Gedankenfutter)<a class="headerlink" href="#zwischenspiel-uber-die-wichtigkeit-der-reihenfolge-losung-zum-gedankenfutter" title="Link zu dieser Überschrift">¶</a></h2>
<p><strong>Sigrid:</strong> Klar ist die Reihenfolge wichtig, sonst werden mit Pech irgendwelche
Variablen überschattet.</p>
<p><strong>Brynja:</strong> Aber wir wissen ja, dass alle Variablen, die wir in einer solchen
Interaktion binden unterschiedlich sind, sie können sich also gar nicht gegenseitig
überschatten.</p>
<p><strong>Alfrothul:</strong> Das heißt wir könnten mehrere verschiedene Umgebungen haben, die
trotzdem immer die gleichen Resultate haben?</p>
<p><strong>Brynja:</strong> Ja, genau. Das heißt in diesem Fall ist die Reihenfolge egal.</p>
<p><strong>Sigrid:</strong> Klingt ganz so wie die Äquivalenz von Funktionen, über die wir neulich
gesprochen haben. Da ist auch die Reihenfolge egal, solange das Ergebnis das gleiche
ist.</p>
<p><strong>Mimer:</strong> Gut bemerkt!</p>
</div>
<div class="section" id="funktionen">
<h2>Funktionen<a class="headerlink" href="#funktionen" title="Link zu dieser Überschrift">¶</a></h2>
<p>Natürlich hat OCaml auch Funktionen. Ohne funktionen könnten wir nicht viel programmieren:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;type_environment&gt; ::= . | ( &lt;name&gt; : &lt;type&gt;), &lt;type_environment&gt;

&lt;type&gt;             ::= int | bool | char | string | &lt;type&gt; * ... * &lt;type&gt; | unit | &lt;type&gt; -&gt; &lt;type&gt;

&lt;expression&gt;       ::= &lt;integer&gt;
                     | &lt;boolean&gt;
                     | &lt;character&gt;
                     | &lt;string&gt;
                     | if &lt;expression&gt; then &lt;expression&gt; else &lt;expression&gt;
                     | (&lt;expression&gt;, ..., &lt;expression&gt;)
                     | &lt;name&gt;
                     | fun &lt;name&gt; -&gt; &lt;expression&gt;
                     | &lt;expression&gt; &lt;expression&gt;

&lt;integer&gt;          ::= 0 | -1 | 1 | -2 | 2 | -3 | 3 | ...

&lt;boolean&gt;          ::= true | false

&lt;character&gt;        ::= &#39;a&#39; | &#39;b&#39; | &#39;c&#39;| ...

&lt;string&gt;           ::= &quot;&quot; | &quot;A&quot; | &quot;hello world&quot; | &quot;42&quot; | ...

&lt;name&gt;             ::= eine Folge von Zeichen, angefangen mit einem Kleinbuchstaben
</pre></div>
</div>
<p>Die entsprechenden Typenregeln sind die folgenden, wo <code class="docutils literal notranslate"><span class="pre">G</span></code> für
<code class="docutils literal notranslate"><span class="pre">&lt;type-environment&gt;</span></code> steht, <code class="docutils literal notranslate"><span class="pre">x1</span></code> für <code class="docutils literal notranslate"><span class="pre">&lt;name&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">e0</span></code>, <code class="docutils literal notranslate"><span class="pre">e1</span></code> und <code class="docutils literal notranslate"><span class="pre">e2</span></code> für
<code class="docutils literal notranslate"><span class="pre">&lt;expression&gt;</span></code>, und <code class="docutils literal notranslate"><span class="pre">t1</span></code> und <code class="docutils literal notranslate"><span class="pre">t2</span></code> für <code class="docutils literal notranslate"><span class="pre">&lt;type&gt;</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    (x1 : t1), G |- e2 : t2
FUN ----------------------------
    G |- fun x1 -&gt; e2 : t1 -&gt; t2

        G |- e0 : t1 -&gt; t2   G |- e1 : t1
APP ---------------------------------
    G |- e0 e1 : t2
</pre></div>
</div>
<p>In Worten:</p>
<ul class="simple">
<li>in einer beliebigen Typenumgebung <code class="docutils literal notranslate"><span class="pre">G</span></code> hat der Ausdruck <code class="docutils literal notranslate"><span class="pre">fun</span> <span class="pre">x1</span> <span class="pre">-&gt;</span> <span class="pre">e2</span></code> den Typen
<code class="docutils literal notranslate"><span class="pre">t1</span> <span class="pre">-&gt;</span> <span class="pre">t2</span></code> unter der Voraussetzung, dass <code class="docutils literal notranslate"><span class="pre">e2</span></code> den Typen <code class="docutils literal notranslate"><span class="pre">t2</span></code> hat in einer
Umgebung wo <code class="docutils literal notranslate"><span class="pre">x1</span></code> den Tyepn <code class="docutils literal notranslate"><span class="pre">t1</span></code> hat; und</li>
<li>in einer beliebigen Typenumgebung <code class="docutils literal notranslate"><span class="pre">G</span></code> in welcher der Ausdruck <code class="docutils literal notranslate"><span class="pre">e0</span></code> den Typen
<code class="docutils literal notranslate"><span class="pre">t1</span> <span class="pre">-&gt;</span> <span class="pre">t2</span></code> und der Ausdruck <code class="docutils literal notranslate"><span class="pre">e1</span></code> den Typen <code class="docutils literal notranslate"><span class="pre">t1</span></code> hat, hat der Ausdruck <code class="docutils literal notranslate"><span class="pre">e0</span>
<span class="pre">e1</span></code> den Typen <code class="docutils literal notranslate"><span class="pre">t2</span></code>.</li>
</ul>
<p>Außerdem:</p>
<ul class="simple">
<li>wenn wir <code class="docutils literal notranslate"><span class="pre">fun</span> <span class="pre">x1</span> <span class="pre">-&gt;</span> <span class="pre">e2</span></code> evaluieren ist das Ergebnis eine Funktion; und</li>
<li>wenn wir <code class="docutils literal notranslate"><span class="pre">e0</span> <span class="pre">e1</span></code> evaluieren, dann evaluieren wir zuerst <code class="docutils literal notranslate"><span class="pre">e0</span></code> und <code class="docutils literal notranslate"><span class="pre">e1</span></code>:<ul>
<li>wenn das Evaluieren eines der beiden Ausdrücke divergiert (unendlich läuft), dann
divergiert auch das Evaluieren von <code class="docutils literal notranslate"><span class="pre">e0</span> <span class="pre">e1</span></code>;</li>
<li>wenn das Evaluieren eines der beiden Ausdrücke einen Fehler hervorruft, ruft das
Evaluieren von <code class="docutils literal notranslate"><span class="pre">e0</span> <span class="pre">e1</span></code> denselben Fehler hervor; und</li>
<li>wenn das Evaluieren von <code class="docutils literal notranslate"><span class="pre">e0</span></code> und <code class="docutils literal notranslate"><span class="pre">e1</span></code> die Werte w0 und w1 ergibt, dann wissen
wir dank OCamls Typensystem, dass w0 eine Funktion ist; <code class="docutils literal notranslate"><span class="pre">e0</span> <span class="pre">e1</span></code> zu evaluieren
bedeutet dann die Funktion w0 auf den Wert w1 anzuwenden.</li>
</ul>
</li>
</ul>
<p>Genau wie bedingte Ausdrücke und Tupel sind Funktionen und Funktionsanwendung
polymorph (können also unterschiedliche Typen als Resultat haben).</p>
</div>
<div class="section" id="vokabular-zu-funktionen">
<h2>Vokabular zu Funktionen<a class="headerlink" href="#vokabular-zu-funktionen" title="Link zu dieser Überschrift">¶</a></h2>
<ul class="simple">
<li>Der Ausdruck <code class="docutils literal notranslate"><span class="pre">fun</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">e</span></code> wir oftmals als <em>Lambda-Abstraktion</em> bezeichnet, und
demnach lesen wir das Keyword <code class="docutils literal notranslate"><span class="pre">fun</span></code> oftmals einfach als „Lambda“.<ul>
<li><code class="docutils literal notranslate"><span class="pre">e</span></code> bezeichnen wir als den <em>Funktionskörper</em> und beschreibt was die Funktion
macht, wenn sie auf ein Input angewandt wird.</li>
<li><code class="docutils literal notranslate"><span class="pre">x</span></code> nennen wir den <em>Formalparameter</em> für die Funktion und ist der Name unter dem das
Input der Funktion dem Funktionskörper zugänglich ist.</li>
</ul>
</li>
<li>Den Ausdruck <code class="docutils literal notranslate"><span class="pre">e0</span> <span class="pre">e1</span></code> nennen wir <em>Funktionsanwendung</em>.<ul>
<li><code class="docutils literal notranslate"><span class="pre">e0</span></code> ist die Funktion, die wir anwenden.</li>
<li><code class="docutils literal notranslate"><span class="pre">e1</span></code> nennen wir den <em>tatsächlichen Parameter</em> oder das <em>Input</em> für die
Funktion.</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="wie-funktionen-funktionieren">
<h2>Wie Funktionen funktionieren<a class="headerlink" href="#wie-funktionen-funktionieren" title="Link zu dieser Überschrift">¶</a></h2>
<p>Wenn eine Lambdaabstraktion wie zum Beispiel die Identitätsfunktion <code class="docutils literal notranslate"><span class="pre">fun</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">x</span></code>
auf einen tatsächlichen Parameter angewandt wird, zum Beispiel <code class="docutils literal notranslate"><span class="pre">42</span></code>, dann
evaluieren wir den Funktionskörper, also <code class="docutils literal notranslate"><span class="pre">x</span></code>, in einer Werteumgebung, in der <code class="docutils literal notranslate"><span class="pre">x</span></code>
für <code class="docutils literal notranslate"><span class="pre">42</span></code> steht:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># (fun x -&gt; x) 42;;
- : int = 42
</pre></div>
</div>
<p>Dass der Ausdruck <code class="docutils literal notranslate"><span class="pre">(fun</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">x)</span> <span class="pre">42</span></code> den Typen <code class="docutils literal notranslate"><span class="pre">int</span></code> hat zeigt der folgende
Beweisbaum, wo <code class="docutils literal notranslate"><span class="pre">Gv</span></code> für eine Werteumgebung steht:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>LOOKUP_FOUND ------------------------
          (x : int), Gv |- x : int
      FUN -----------------------------    INT --------------
          Gv |- fun x -&gt; x : int -&gt; int        Gv |- 42 : int
      APP ---------------------------------------------------
          Gv |- (fun x -&gt; x) 42 : int
</pre></div>
</div>
<p>(Hinweis: Die Klammern hier sind wichtig um OCaml zu zeigen, dass der Funktionskörper
nur <code class="docutils literal notranslate"><span class="pre">x</span></code> ist und nicht <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">42</span></code>. Probiere aus, was passiert wenn du den Ausdruck
ohne Klammern eingibst. Die Erklärung dazu ist, dass OCaml nun erwartet, dass das
Input <code class="docutils literal notranslate"><span class="pre">x</span></code> einen Funktionstypen hat und der Funktionskörper dieser Lambdaabstraktion
das Input auf <code class="docutils literal notranslate"><span class="pre">42</span></code> anwendet.)</p>
<p>Ein anderes Beispiel ist die Lambdaabstraktion <code class="docutils literal notranslate"><span class="pre">fun</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">if</span> <span class="pre">b</span> <span class="pre">then</span> <span class="pre">&quot;joa&quot;</span> <span class="pre">else</span>
<span class="pre">&quot;nö&quot;</span></code>. Diese Lambdaabstraktion hat den Typen <code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">-&gt;</span> <span class="pre">string</span></code>, denn ihr Input wird
als Test in einem bedingten Ausdruck verwendet, dessen Resultat ein String ist. Wenn
wir die Abstraktion auf <code class="docutils literal notranslate"><span class="pre">true</span></code> anwenden, dann evaluieren wir den Funktionskörper
(also <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">b</span> <span class="pre">then</span> <span class="pre">&quot;joa&quot;</span> <span class="pre">else</span> <span class="pre">&quot;nö&quot;)</span> <span class="pre">in</span> <span class="pre">einer</span> <span class="pre">Umgebung</span> <span class="pre">wo</span> <span class="pre">``b</span></code> für <code class="docutils literal notranslate"><span class="pre">true</span></code> steht; wenn
wir die Abstraktion auf <code class="docutils literal notranslate"><span class="pre">false</span></code> anwenden, dann evaluieren wir den Funktionskörper
(also <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">b</span> <span class="pre">then</span> <span class="pre">&quot;joa&quot;</span> <span class="pre">else</span> <span class="pre">&quot;nö&quot;)</span> <span class="pre">in</span> <span class="pre">einer</span> <span class="pre">Umgebung</span> <span class="pre">wo</span> <span class="pre">``b</span></code> für <code class="docutils literal notranslate"><span class="pre">false</span></code> steht:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># fun b -&gt; if b then &quot;joa&quot; else &quot;nö&quot;;;
- : bool -&gt; string = &lt;fun&gt;
# (fun b -&gt; if b then &quot;joa&quot; else &quot;nö&quot;) true;;
- : string = &quot;joa&quot;
# (fun b -&gt; if b then &quot;joa&quot; else &quot;nö&quot;) false;;
- : string = &quot;nö&quot;
#
</pre></div>
</div>
<p>Im Folgenden ein paar Beweisbäume darüber, wie diese Werte zustande kommen:</p>
<ul>
<li><p class="first">Dass <code class="docutils literal notranslate"><span class="pre">fun</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">if</span> <span class="pre">b</span> <span class="pre">then</span> <span class="pre">&quot;joa&quot;</span> <span class="pre">else</span> <span class="pre">&quot;nö&quot;</span></code> den Typen <code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">-&gt;</span> <span class="pre">string</span></code> hat
beweisen wir so:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>LOOKUP_FOUND --------------------------    STRING ----------------------------------    STRING ----------------------------------
              (b : bool), Gv |- b : bool           (b : bool), Gv |- &quot;joa&quot; : string           (b : bool), Gv |- &quot;nö&quot; : string
     IF ---------------------------------------------------------------------------------------------------------------------
        (b : bool), Gv |- if b then &quot;joa&quot; else &quot;nö&quot; : string
    FUN --------------------------------------------------------------
        Gv |- fun b -&gt; if b then &quot;joa&quot; else &quot;nö&quot; : bool -&gt; string
</pre></div>
</div>
</li>
<li><p class="first">Dass <code class="docutils literal notranslate"><span class="pre">(fun</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">if</span> <span class="pre">b</span> <span class="pre">then</span> <span class="pre">&quot;joa&quot;</span> <span class="pre">else</span> <span class="pre">&quot;nö&quot;)</span> <span class="pre">true</span></code> den Typen <code class="docutils literal notranslate"><span class="pre">string</span></code> hat
beweisen wir so:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     ...siehe oben...
FUN --------------------------------------------------------------    BOOL_TRUE -----------------
    Gv |- fun b -&gt; if b then &quot;joa&quot; else &quot;nö&quot; : bool -&gt; string              Gv |- true : bool
APP ---------------------------------------------------------------------------------------------
    Gv |- (fun b -&gt; if b then &quot;joa&quot; else &quot;nö&quot;) true : string
</pre></div>
</div>
</li>
<li><p class="first">Dass <code class="docutils literal notranslate"><span class="pre">(fun</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">if</span> <span class="pre">b</span> <span class="pre">then</span> <span class="pre">&quot;joa&quot;</span> <span class="pre">else</span> <span class="pre">&quot;nö&quot;)</span> <span class="pre">false</span></code> den Tyepn <code class="docutils literal notranslate"><span class="pre">string</span></code> hat
beweisen wir so:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     ...siehe oben...
FUN --------------------------------------------------------------    BOOL_FALSE -----------------
    Gv |- fun b -&gt; if b then &quot;joa&quot; else &quot;nö&quot; : bool -&gt; string              Gv |- false : bool
APP ---------------------------------------------------------------------------------------------
    Gv |- (fun b -&gt; if b then &quot;joa&quot; else &quot;nö&quot;) false : string
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="vordefinierte-funktionen">
<h2>Vordefinierte Funktionen<a class="headerlink" href="#vordefinierte-funktionen" title="Link zu dieser Überschrift">¶</a></h2>
<p>Genauso wie OCaml vordefinierte Werte von anderen Typen hat (z.B. <code class="docutils literal notranslate"><span class="pre">max_int</span></code>), gibt
es auch vordefinierte Werte mit Funktionstypen. Hier sind ein paar Beispiele.</p>
<ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">not</span></code> hat den Typen <code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></code> und gibt das Gegenteil seines Inputs als
Output:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># not;;
- : bool -&gt; bool = &lt;fun&gt;
# not true;;
- : bool = false
# not false;;
- : bool = true
# not (not true);;
- : bool = true
# not (not false);;
- : bool = false
#
</pre></div>
</div>
</li>
</ul>
<p>Viele vordefinierte Funktionen in OCaml sind in sogenannten Bibliotheken (libraries)
definiert. Wenn wir zum Beispiel eine Funktion aus der Bibliothek für Strings
benutzen möchten, erzählen wir OCaml erst, dass wir diese Bibliothek benutzen wollen
indem wir <code class="docutils literal notranslate"><span class="pre">String</span></code> schreiben, dann dass wir aus dieser Bibliothek zum Beispiel die
Funktion <code class="docutils literal notranslate"><span class="pre">length</span></code> bentuzen wollen indem wir es mit einem <code class="docutils literal notranslate"><span class="pre">.</span></code> dazwischen anhängen:</p>
<ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">String.length</span></code> hat den Typen <code class="docutils literal notranslate"><span class="pre">string</span> <span class="pre">-&gt;</span> <span class="pre">int</span></code> ist in der Bibliothek für
Strings deklariert. Wenn wir <code class="docutils literal notranslate"><span class="pre">String.length</span></code> einen String als Input geben, ist
das Ergebnis der Funktionsanwendung ein Integer, der angibt wie viele Zeichen
dieser String hat:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># String.length;;
- : string -&gt; int = &lt;fun&gt;
# String.length &quot;&quot;;;
- : int = 0
# String.length &quot;a&quot;;;
- : int = 1
# String.length &quot;ab&quot;;;
- : int = 2
# String.length &quot;abc&quot;;;
- : int = 3
#
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="kurzes-zwischenspiel-uber-die-lange-eines-backslash">
<h2>Kurzes Zwischenspiel über die Länge eines Backslash<a class="headerlink" href="#kurzes-zwischenspiel-uber-die-lange-eines-backslash" title="Link zu dieser Überschrift">¶</a></h2>
<p><strong>Alfrothul:</strong> Ich muss mal was überprüfen:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># String.length &quot;\&quot;&quot;;;
- : int = 1
#
</pre></div>
</div>
<p><strong>Alfrothul:</strong> Yup! Ein Zeichen, genau wie es sein soll. Der Backslash ist nur eine
Notation.</p>
<p><strong>Brynja:</strong> Ich muss auch was ausprobieren:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># String.length &quot;\\\\\\&quot;;;
- : int = 3
#
</pre></div>
</div>
<p><strong>Brynja:</strong> Stimmt. Drei Zeichen. Prima!</p>
</div>
<div class="section" id="funktionen-deren-resultate-funktionen-sind">
<h2>Funktionen, deren Resultate Funktionen sind<a class="headerlink" href="#funktionen-deren-resultate-funktionen-sind" title="Link zu dieser Überschrift">¶</a></h2>
<p>Im Prinzip hält uns nichts davon ab, Funktionen zu schreiben, deren Resultate
ebenfalls Funktionen sind. Wir können dann so einer Funktion ein erstes Argument
geben und dem Resultat ein zweites:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># fun x -&gt; (fun y -&gt; x);;
- : &#39;a -&gt; &#39;b -&gt; &#39;a = &lt;fun&gt;
# (fun x -&gt; (fun y -&gt; x)) 42;;
- : &#39;_weak1 -&gt; int = &lt;fun&gt;
# ((fun x -&gt; (fun y -&gt; x)) 42) &quot;gib mir meine 42 zurück!&quot;;;
- : int = 42
#
</pre></div>
</div>
<p>(Kommentar: der Typ <code class="docutils literal notranslate"><span class="pre">'_weak1</span></code> ist einfach ein Platzhalter für einen beliebigen
Typen, ebenso wie die Typen <code class="docutils literal notranslate"><span class="pre">'a</span></code> und <code class="docutils literal notranslate"><span class="pre">'b</span></code> Platzhalter für beliebige Typen
sind. Warum OCaml im zweiten Ausdruck jedoch <code class="docutils literal notranslate"><span class="pre">'weak_1</span></code> schreibt geht über den
Umfang dieses Kurses hinaus.)</p>
<p>Einige von den Klammern sind unnötig. Funktionsanwendung ist links-assoziativ und
Lambdaabstraktionen sind rechts-assoziativ. Daher können das ganze auch so schreiben:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># fun x -&gt; fun y -&gt; x;;
- : &#39;a -&gt; &#39;b -&gt; &#39;a = &lt;fun&gt;
# (fun x -&gt; fun y -&gt; x) 42;;
- : &#39;_weak2 -&gt; int = &lt;fun&gt;
# (fun x -&gt; fun y -&gt; x) 42 &quot;gib mir meine 42 zurück!&quot;;;
- : int = 42
#
</pre></div>
</div>
<p>Wenn wir diese Lambdaabstraktion <code class="docutils literal notranslate"><span class="pre">fun</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">fun</span> <span class="pre">y</span> <span class="pre">-&gt;</span> <span class="pre">x</span></code> beschreiben sollten, wäre
das wie folgt:</p>
<ul class="simple">
<li>das Ergebnis der Funktionsanwendung von <code class="docutils literal notranslate"><span class="pre">fun</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">fun</span> <span class="pre">y</span> <span class="pre">-&gt;</span> <span class="pre">x</span></code> mit einem Wert
<code class="docutils literal notranslate"><span class="pre">e</span></code> als tatsächlichen Parameter ist eine Funktion, die für ein beliebiges Input
<code class="docutils literal notranslate"><span class="pre">e2</span></code> als Ergebnis <code class="docutils literal notranslate"><span class="pre">e</span></code> hat.</li>
</ul>
<p>Oder, wenn wir das Ergebnis als Lambdaabstraktion darstellen sollten:</p>
<ul class="simple">
<li>Für einen beliebigen Ausdruck <code class="docutils literal notranslate"><span class="pre">e</span></code> ist das Ergebnis der Funktionsanwendung von
<code class="docutils literal notranslate"><span class="pre">(fun</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">fun</span> <span class="pre">y</span> <span class="pre">-&gt;</span> <span class="pre">x)</span> <span class="pre">e</span></code> die Lambdaabstraktion <code class="docutils literal notranslate"><span class="pre">fun</span> <span class="pre">y</span> <span class="pre">-&gt;</span> <span class="pre">e</span></code>.</li>
</ul>
<p>Was bei der Funktionsanwendung also faktisch passiert ist, dass alle Stellen, an
denen im Funktionskörper der formelle Parameter <code class="docutils literal notranslate"><span class="pre">x</span></code> verwendet wird nun der
tatsächliche Parameter <code class="docutils literal notranslate"><span class="pre">e</span></code> eingesetzt wird.</p>
<p>Ein anderes Beispiel wäre eine Funktion, die für ein beliebiges Input immer die
Idenitätsfunktion (also eine Funktion, die immer ihr Input unverändert als Output
gibt) zurück gibt:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># fun x -&gt; fun y -&gt; y;;
- : &#39;a -&gt; &#39;b -&gt; &#39;b = &lt;fun&gt;
# (fun x -&gt; fun y -&gt; y) 1 2;;
- : int = 2
# (fun x -&gt; fun y -&gt; y) &quot;druck mich!&quot; &quot;nö&quot;;;
- : string = &quot;nö&quot;
#
</pre></div>
</div>
</div>
<div class="section" id="beweisbaume-fur-interessierte">
<h2>Beweisbäume für Interessierte<a class="headerlink" href="#beweisbaume-fur-interessierte" title="Link zu dieser Überschrift">¶</a></h2>
<p>Für wen das mit den Funktionen noch nicht einleuchtend ist, sind hier ein paar
Beweisbäume:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>        LOOKUP_FOUND ------------------------
                     (x : int), Gv |- x : int
LOOKUP_NOT_FOUND_YET -----------------------------------
                     (y : int), (x : int), Gv |- x : int
              FUN ----------------------------------------
                  (x : int), Gv |- fun y -&gt; x : int -&gt; int
              FUN -----------------------------------------------    INT -------------
                  Gv |- fun x -&gt; fun y -&gt; x : int -&gt; (int -&gt; int)        Gv |- 1 : int
              APP --------------------------------------------------------------------    INT -------------
                  Gv |- (fun x -&gt; fun y -&gt; x) 1 : int -&gt; int                                  Gv |- 2 : int
              APP -----------------------------------------------------------------------------------------
                  Gv |- ((fun x -&gt; fun y -&gt; x) 1) 2 : int
</pre></div>
</div>
<p>Und für die Funktion, die die Identitätsfunktion als Output gibt:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>LOOKUP_FOUND -----------------------------------
            (y : int), (x : int), Gv |- y : int
      FUN ----------------------------------------
          (x : int), Gv |- fun y -&gt; y : int -&gt; int
      FUN -----------------------------------------------    INT -------------
          Gv |- fun x -&gt; fun y -&gt; y : int -&gt; (int -&gt; int)        Gv |- 1 : int
      APP --------------------------------------------------------------------    INT -------------
          Gv |- (fun x -&gt; fun y -&gt; y) 1 : int -&gt; int                                  Gv |- 2 : int
      APP -----------------------------------------------------------------------------------------
          Gv |- ((fun x -&gt; fun y -&gt; y) 1) 2 : int
</pre></div>
</div>
</div>
<div class="section" id="syntaktischer-zucker-fur-funktionen-die-funktionen-zuruck-geben">
<h2>Syntaktischer Zucker für Funktionen, die Funktionen zurück geben<a class="headerlink" href="#syntaktischer-zucker-fur-funktionen-die-funktionen-zuruck-geben" title="Link zu dieser Überschrift">¶</a></h2>
<p>Im Alltag wäre es echt nervig, wenn wir für solche Lambdaabstraktionen immer
<code class="docutils literal notranslate"><span class="pre">fun</span> <span class="pre">-&gt;</span> <span class="pre">fun</span> <span class="pre">y</span> <span class="pre">-&gt;</span> <span class="pre">...</span></code> schreiben müssten. Daher gibt es eine Kurzform:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># (fun x -&gt; fun y -&gt; x) 1 10;;
- : int = 1
# (fun x y -&gt; x) 1 10;;
- : int = 1
# (fun x -&gt; fun y -&gt; y) 1 10;;
- : int = 10
# (fun x y -&gt; y) 1 10;;
- : int = 10
#
</pre></div>
</div>
<p>Solche Abkürzungen, die praktische Erweiterungen zur Syntax sind, nennen wir syntaktischen
Zucker; danke für diesen Ausdruck, <a class="reference external" href="https://de.wikipedia.org/wiki/Peter_J._Landin">Peter Landin</a>.</p>
</div>
<div class="section" id="vordefinierte-funktionen-deren-outputs-funktionen-sind-integer-addition">
<h2>Vordefinierte Funktionen, deren Outputs Funktionen sind: Integer Addition<a class="headerlink" href="#vordefinierte-funktionen-deren-outputs-funktionen-sind-integer-addition" title="Link zu dieser Überschrift">¶</a></h2>
<p>In OCaml ist die normale Art Addition zu schreiben der Infix-Operator <code class="docutils literal notranslate"><span class="pre">+</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># 2 + 40;;
- : int = 42
#
</pre></div>
</div>
<p>Dieses <code class="docutils literal notranslate"><span class="pre">+</span></code> ist aber in wirklichkeit nichts anderes als Syntaktischer Zucker für die
Funktion <code class="docutils literal notranslate"><span class="pre">add</span></code> in der Bibliothek <code class="docutils literal notranslate"><span class="pre">Int</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># Int.add 2 40;;
- : int = 42
#
</pre></div>
</div>
<p>Wenn wir <code class="docutils literal notranslate"><span class="pre">Int.add</span></code> auf diese Art schreiben wollen, wie die Funktionen die wir
bisher gesehen haben, dann gibt es auch dafür syntaktischen Zucker:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># (+) 1 10;;
- : int = 11
#
</pre></div>
</div>
<p>Der Typ von <code class="docutils literal notranslate"><span class="pre">Int.add</span></code> ist ein Funktionstyp, der wiederup einen Funktionstypen auf
der rechten Seite des Pfeils hat:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># (+);;
- : int -&gt; int -&gt; int = &lt;fun&gt;
#
</pre></div>
</div>
<p>Wir können nun also auch damit herumspielen, dieser Funktion nur ein Input zu
geben. Wenn wir zum Beispiel <code class="docutils literal notranslate"><span class="pre">(+)</span> <span class="pre">1</span></code> nehmen, bekommen wir als Resultat eine neue
Funktion, die einen Integer als Input nimmt (z.B. 10) und als Output diesen Integer
plus 1 gibt (z.B. 11):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># (+) 1;;
- : int -&gt; int = &lt;fun&gt;
# ((+) 1) 10;;
- : int = 11
#
</pre></div>
</div>
</div>
<div class="section" id="funktionen-als-variablen">
<h2>Funktionen als Variablen<a class="headerlink" href="#funktionen-als-variablen" title="Link zu dieser Überschrift">¶</a></h2>
<p>Wir können nun auch die Konstrukte, die wir diese Woche gelernt haben zusammensetzen:
Wir können Funktionen als globale Variablen speichern. Nehmen wir das Beispiel von
der Funktion, die immer 1 zu ihrem Input hinzufügt:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># let nachfolger = (+) 1;;
val nachfolger : int -&gt; int = &lt;fun&gt;
# nachfolger;;
- : int -&gt; int = &lt;fun&gt;
#
</pre></div>
</div>
<p>Wenn wir also diese Funktion nun anwenden wollen, können wir sie über ihren neu
definierten Namen aufrufen:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># nachfolger 10;;
- : int = 11
# nachfolger 41;;
- : int = 42
#
</pre></div>
</div>
</div>
<div class="section" id="ubung-27">
<h2>Übung 27<a class="headerlink" href="#ubung-27" title="Link zu dieser Überschrift">¶</a></h2>
<p>Die Funktion <code class="docutils literal notranslate"><span class="pre">Int.sub</span></code>, oder <code class="docutils literal notranslate"><span class="pre">(-)</span></code> ist die Subtraktionsfunktion für Integer in
OCaml.</p>
<ul class="simple">
<li>Definiere eine Vorgänger-Funktion, die von ihrem Input immer 1 abzieht.</li>
<li>Definiere eine Funktion <code class="docutils literal notranslate"><span class="pre">minus_10</span></code>, die von ihrem Input 10 abzieht.</li>
</ul>
</div>
<div class="section" id="noch-mehr-vordefinierte-funktionen-die-funktionen-als-output-geben">
<h2>Noch mehr vordefinierte Funktionen, die Funktionen als Output geben<a class="headerlink" href="#noch-mehr-vordefinierte-funktionen-die-funktionen-als-output-geben" title="Link zu dieser Überschrift">¶</a></h2>
<ul>
<li><p class="first">Multiplikation (<code class="docutils literal notranslate"><span class="pre">Int.mul</span></code>):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># 2 * 3;;
- : int = 6
#
</pre></div>
</div>
</li>
<li><p class="first">Quotient (Division ohne Komma oder Rest):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># (/);;
- : int -&gt; int -&gt; int = &lt;fun&gt;
# 16 / 2;;
- : int = 8
# 3 / 2;;
- : int = 1
# 1 / 0;;
Exception: Division_by_zero.
#
</pre></div>
</div>
</li>
<li><p class="first">Modulo (der Rest bei einer Integer-Division):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># (mod);;
- : int -&gt; int -&gt; int = &lt;fun&gt;
# Int.rem 10 3;;
- : int = 1
# 12 mod 5;;
- : int = 2
#
</pre></div>
</div>
</li>
<li><p class="first">Vergleich von zwei Werten:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># (&lt;);;
- : &#39;a -&gt; &#39;a -&gt; bool = &lt;fun&gt;
# &#39;a&#39;&lt;&#39;b&#39;;;
- : bool = true
# 1 &lt; 0;;
- : bool = false
# (&gt;);;
- : &#39;a -&gt; &#39;a -&gt; bool = &lt;fun&gt;
# 3 &gt; 1;;
- : bool = true
# 4 &gt; 29;;
- : bool = false
#
</pre></div>
</div>
</li>
<li><p class="first">Boolsche Konjunktion (und):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># (&amp;&amp;);;
- : bool -&gt; bool -&gt; bool = &lt;fun&gt;
# false &amp;&amp; true;;
- : bool = false
# true &amp;&amp; true;;
- : bool = true
# true &amp;&amp; false;;
- : bool = false
# false &amp;&amp; false;;
- : bool = false
#
</pre></div>
</div>
</li>
<li><p class="first">Boolsche Disjunktion (oder):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># (||);;
- : bool -&gt; bool -&gt; bool = &lt;fun&gt;
# true || true;;
- : bool = true
# true || false;;
- : bool = true
#
</pre></div>
</div>
</li>
<li><p class="first">String-Konkatenation (Zusammensetzung):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># (^);;
- : string -&gt; string -&gt; string = &lt;fun&gt;
# &quot;hello&quot; ^ &quot; world&quot;;;
- : string = &quot;hello world&quot;
#
</pre></div>
</div>
</li>
<li><p class="first">Minimum von zwei Werten:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># min;;
- : &#39;a -&gt; &#39;a -&gt; &#39;a = &lt;fun&gt;
# min 2 4;;
- : int = 2
# min 9 230;;
- : int = 9
#
</pre></div>
</div>
</li>
<li><p class="first">Maximum von zwei Werten:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># max;;
- : &#39;a -&gt; &#39;a -&gt; &#39;a = &lt;fun&gt;
# max 3 5;;
- : int = 5
# max 42 11;;
- : int = 42
#
</pre></div>
</div>
</li>
<li><p class="first">Eine Funktion, die ein bestimmtes Zeichen aus einem String isoliert:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># String.get;;
- : string -&gt; int -&gt; char = &lt;fun&gt;
# String.get &quot;hello world&quot; 4;;
- : char = &#39;o&#39;
# String.get &quot;0123456&quot; 6;;
- : char = &#39;6&#39;
# String.get &quot;1234567&quot; 5;;
- : char = &#39;6&#39;
#
</pre></div>
</div>
<p>Achtung bei dieser Funktion. Bei den meisten Programmiersprachen fangen wir das
Zählen bei Null an; so auch in OCaml.</p>
</li>
</ul>
</div>
<div class="section" id="ubung-28">
<h2>Übung 28<a class="headerlink" href="#ubung-28" title="Link zu dieser Überschrift">¶</a></h2>
<p>Probiere die Funktionen aus dem vorigen Abschnitt an unterschiedlichen Inputs aus bis
du sie verstanden hast.</p>
<p>Definiere auch gerne neue Funktionen, indem du den Funktionen aus dem vorigen
Abschnitt nur ein Input gibst. Mach dir vorher klar, was du von der neuen Funktion
erwartest und probiere sie an unterschiedlichen Inputs aus um sicher zu gehen, dass
du richtig gelegen hast.</p>
</div>
<div class="section" id="version-of-variablen-und-funktionen">
<h2>Version of „variablen-und-funktionen“<a class="headerlink" href="#version-of-variablen-und-funktionen" title="Link zu dieser Überschrift">¶</a></h2>
<p>Erstellt [2023-01-29]</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Namen und Funktionen (der Rest der OCaml-Grammatik)</a><ul>
<li><a class="reference internal" href="#namen-und-typenumgebungen">Namen und Typenumgebungen</a></li>
<li><a class="reference internal" href="#ubung-25">Übung 25</a></li>
<li><a class="reference internal" href="#teilweise-losung-fur-ubung-25">Teilweise Lösung für Übung 25</a></li>
<li><a class="reference internal" href="#zwischenspiel-uber-umgebungen-und-zwiebeln">Zwischenspiel über Umgebungen und Zwiebeln</a></li>
<li><a class="reference internal" href="#globale-variablen-deklarieren">Globale Variablen deklarieren</a></li>
<li><a class="reference internal" href="#ubung-26">Übung 26</a></li>
<li><a class="reference internal" href="#mehrere-globale-variablen-auf-einmal-deklarieren">Mehrere globale Variablen auf einmal deklarieren</a></li>
<li><a class="reference internal" href="#zwischenspiel-uber-die-wichtigkeit-der-reihenfolge-losung-zum-gedankenfutter">Zwischenspiel über die Wichtigkeit der Reihenfolge (Lösung zum Gedankenfutter)</a></li>
<li><a class="reference internal" href="#funktionen">Funktionen</a></li>
<li><a class="reference internal" href="#vokabular-zu-funktionen">Vokabular zu Funktionen</a></li>
<li><a class="reference internal" href="#wie-funktionen-funktionieren">Wie Funktionen funktionieren</a></li>
<li><a class="reference internal" href="#vordefinierte-funktionen">Vordefinierte Funktionen</a></li>
<li><a class="reference internal" href="#kurzes-zwischenspiel-uber-die-lange-eines-backslash">Kurzes Zwischenspiel über die Länge eines Backslash</a></li>
<li><a class="reference internal" href="#funktionen-deren-resultate-funktionen-sind">Funktionen, deren Resultate Funktionen sind</a></li>
<li><a class="reference internal" href="#beweisbaume-fur-interessierte">Beweisbäume für Interessierte</a></li>
<li><a class="reference internal" href="#syntaktischer-zucker-fur-funktionen-die-funktionen-zuruck-geben">Syntaktischer Zucker für Funktionen, die Funktionen zurück geben</a></li>
<li><a class="reference internal" href="#vordefinierte-funktionen-deren-outputs-funktionen-sind-integer-addition">Vordefinierte Funktionen, deren Outputs Funktionen sind: Integer Addition</a></li>
<li><a class="reference internal" href="#funktionen-als-variablen">Funktionen als Variablen</a></li>
<li><a class="reference internal" href="#ubung-27">Übung 27</a></li>
<li><a class="reference internal" href="#noch-mehr-vordefinierte-funktionen-die-funktionen-als-output-geben">Noch mehr vordefinierte Funktionen, die Funktionen als Output geben</a></li>
<li><a class="reference internal" href="#ubung-28">Übung 28</a></li>
<li><a class="reference internal" href="#version-of-variablen-und-funktionen">Version of „variablen-und-funktionen“</a></li>
</ul>
</li>
</ul>

  <h4>Vorheriges Thema</h4>
  <p class="topless"><a href="week-05-index.html"
                        title="vorheriges Kapitel">Lehrmaterial Woche-05</a></p>
  <h4>Nächstes Thema</h4>
  <p class="topless"><a href="../week-06/week-06_index.html"
                        title="nächstes Kapitel">Lehrmaterial für Woche 06</a></p>
  <div role="note" aria-label="source link">
    <h3>Diese Seite</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/week-05/week-05-variablen-und-funktionen.rst.txt"
            rel="nofollow">Quellcode anzeigen</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Schnellsuche</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Los" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Stichwortverzeichnis"
             >Index</a></li>
        <li class="right" >
          <a href="../week-06/week-06_index.html" title="Lehrmaterial für Woche 06"
             >weiter</a> |</li>
        <li class="right" >
          <a href="week-05-index.html" title="Lehrmaterial Woche-05"
             >zurück</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Einführung ins Programmieren 2022</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="week-05-index.html" >Lehrmaterial Woche-05</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2022, Kira Kutscher.
      Mit <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5 erstellt.
    </div>
  </body>
</html>