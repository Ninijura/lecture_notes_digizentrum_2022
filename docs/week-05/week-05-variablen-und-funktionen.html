
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="de">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Namen und Funktionen (der Rest der OCaml-Grammatik) &#8212; Einführung ins Programmieren 2022</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/extra-styles.css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Stichwortverzeichnis" href="../genindex.html" />
    <link rel="search" title="Suche" href="../search.html" />
    <link rel="next" title="Dramatis Personae" href="../resources/dramatis_personae.html" />
    <link rel="prev" title="Lehrmaterial Woche-05" href="week-05-index.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Stichwortverzeichnis"
             accesskey="I">Index</a></li>
        <li class="right" >
          <a href="../resources/dramatis_personae.html" title="Dramatis Personae"
             accesskey="N">weiter</a> |</li>
        <li class="right" >
          <a href="week-05-index.html" title="Lehrmaterial Woche-05"
             accesskey="P">zurück</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Einführung ins Programmieren 2022</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="week-05-index.html" accesskey="U">Lehrmaterial Woche-05</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="namen-und-funktionen-der-rest-der-ocaml-grammatik">
<h1>Namen und Funktionen (der Rest der OCaml-Grammatik)<a class="headerlink" href="#namen-und-funktionen-der-rest-der-ocaml-grammatik" title="Link zu dieser Überschrift">¶</a></h1>
<p>In diesem Teil des Lehrmaterials lernen wir endlich das, was unsere Programme
interessant macht.</p>
<div class="section" id="namen-und-typenumgebungen">
<h2>Namen und Typenumgebungen<a class="headerlink" href="#namen-und-typenumgebungen" title="Link zu dieser Überschrift">¶</a></h2>
<p>OCaml gibt uns die Möglichkeit, Namen festzulegen. Diese Namen werden oftmals auch
als „Identifikatoren“ oder „Variablen“ bezeichnet und ihre Typen werden in der
Typenumgebung gespeichert:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;type_environment&gt; ::= . | ( &lt;name&gt; : &lt;type&gt;), &lt;type_environment&gt;

&lt;type&gt;             ::= int | bool | char | string | &lt;type&gt; * ... * &lt;type&gt; | unit

&lt;expression&gt;       ::= &lt;integer&gt;
                     | &lt;boolean&gt;
                     | &lt;character&gt;
                     | &lt;string&gt;
                     | if &lt;expression&gt; then &lt;expression&gt; else &lt;expression&gt;
                     | (&lt;expression&gt;, ..., &lt;expression&gt;)
                     | &lt;name&gt;

&lt;integer&gt;          ::= 0 | -1 | 1 | -2 | 2 | -3 | 3 | ...

&lt;boolean&gt;          ::= true | false

&lt;character&gt;        ::= &#39;a&#39; | &#39;b&#39; | &#39;c&#39;| ...

&lt;string&gt;           ::= &quot;&quot; | &quot;A&quot; | &quot;hello world&quot; | &quot;42&quot; | ...

&lt;name&gt;             ::= eine Folge von Zeichen, angefangen mit einem Kleinbuchstaben
</pre></div>
</div>
<p>Die Typenumgebung enthält eine Sammlung von Bindungen zwischen Namen und den
entsprechenden Typen. Es ist aufgebaut wie die sprichwörtliche Zwiebel: Innen ist ein
Keim und darum liegt eine Schicht nach der anderen:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">.</span></code> repräsentiert eine leere Typenumgebung; und</li>
<li>nehmen wir einen Namen <code class="docutils literal notranslate"><span class="pre">x</span></code>, einen Typen <code class="docutils literal notranslate"><span class="pre">t</span></code> und eine Typenumgebung <code class="docutils literal notranslate"><span class="pre">G</span></code>, dann
repräsentiert <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">:</span> <span class="pre">t),</span> <span class="pre">G</span></code> die Erweiterung der Typenumgebung <code class="docutils literal notranslate"><span class="pre">G</span></code> um die Bindung
von <code class="docutils literal notranslate"><span class="pre">x</span></code> zum Typen <code class="docutils literal notranslate"><span class="pre">t</span></code>.</li>
</ul>
<p>Also zum Beispiel:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">.</span></code> ist die leere Typenumgebung, die keine Bindungen zwischen Namen und Typen
enthält.</li>
<li><code class="docutils literal notranslate"><span class="pre">(c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.</span></code> erweitert die vorige Typenumgebung mit der Bindung des Namens
<code class="docutils literal notranslate"><span class="pre">c</span></code> zum Typen <code class="docutils literal notranslate"><span class="pre">char</span></code>. In dieser Typenumgebung hat also <code class="docutils literal notranslate"><span class="pre">c</span></code> den Typen
<code class="docutils literal notranslate"><span class="pre">char</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">(b</span> <span class="pre">:</span> <span class="pre">bool),</span> <span class="pre">((c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.)</span></code> erweitert die vorige Typenumgebung um die Bindung
des Namens <code class="docutils literal notranslate"><span class="pre">b</span></code> zum Typen <code class="docutils literal notranslate"><span class="pre">bool</span></code>. Hier hat also der Name <code class="docutils literal notranslate"><span class="pre">c</span></code> den Typen
<code class="docutils literal notranslate"><span class="pre">char</span></code> und der Name <code class="docutils literal notranslate"><span class="pre">b</span></code> den Typen <code class="docutils literal notranslate"><span class="pre">bool</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">(i</span> <span class="pre">:</span> <span class="pre">int),</span> <span class="pre">((b:</span> <span class="pre">bool),</span> <span class="pre">((c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.))</span></code> erweitert die vorige Typenumgebung um
die Bindung des Namens <code class="docutils literal notranslate"><span class="pre">i</span></code> zum Typen <code class="docutils literal notranslate"><span class="pre">int</span></code>. Hier hat also der Name <code class="docutils literal notranslate"><span class="pre">i</span></code> den
Typen <code class="docutils literal notranslate"><span class="pre">int</span></code>, der Name <code class="docutils literal notranslate"><span class="pre">b</span></code> den Typen <code class="docutils literal notranslate"><span class="pre">bool</span></code> und der Name <code class="docutils literal notranslate"><span class="pre">c</span></code> den Typen
<code class="docutils literal notranslate"><span class="pre">char</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">(b</span> <span class="pre">:</span> <span class="pre">string),</span> <span class="pre">((i</span> <span class="pre">:</span> <span class="pre">int),</span> <span class="pre">((b</span> <span class="pre">:</span> <span class="pre">bool),</span> <span class="pre">((c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.)))</span></code> erweitert die vorige
Typenumgebung um die Bindung des Namens <code class="docutils literal notranslate"><span class="pre">b</span></code> zum Typen <code class="docutils literal notranslate"><span class="pre">string</span></code>. Hier hat der
Name <code class="docutils literal notranslate"><span class="pre">b</span></code> den Typen <code class="docutils literal notranslate"><span class="pre">string</span></code>, der Name <code class="docutils literal notranslate"><span class="pre">i</span></code> den Typen <code class="docutils literal notranslate"><span class="pre">int</span></code> und der Name
<code class="docutils literal notranslate"><span class="pre">c</span></code> de Typen <code class="docutils literal notranslate"><span class="pre">char</span></code>.</li>
</ul>
<p>Die Frage stellt sich nun, warum in der letzten Typenumgebung der Name <code class="docutils literal notranslate"><span class="pre">b</span></code> den
Typen <code class="docutils literal notranslate"><span class="pre">string</span></code> hat und nicht den Typen <code class="docutils literal notranslate"><span class="pre">bool</span></code>. Das liegt daran, dass die
Typeumgebung von außen nach innen gelesen wird und die neueste Bindung diejenige ist,
die zählt. Die Bindung von <code class="docutils literal notranslate"><span class="pre">(b</span> <span class="pre">:</span> <span class="pre">string)</span></code> „überschattet“ („shadows“) also die
ältere Bindung von <code class="docutils literal notranslate"><span class="pre">(b</span> <span class="pre">:</span> <span class="pre">bool)</span></code>.</p>
<p>Der Infix-Konstruktor <code class="docutils literal notranslate"><span class="pre">,</span></code> ist rechts-assoziativ, weshalb wir die Klammern rechts
vom <code class="docutils literal notranslate"><span class="pre">,</span></code> auch weg lassen können:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">(b</span> <span class="pre">:</span> <span class="pre">bool),</span> <span class="pre">(c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.</span></code> ist kurz für <code class="docutils literal notranslate"><span class="pre">(b</span> <span class="pre">:</span> <span class="pre">bool),</span> <span class="pre">((c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.)</span></code>,</li>
<li><code class="docutils literal notranslate"><span class="pre">(i</span> <span class="pre">:</span> <span class="pre">int),</span> <span class="pre">(b</span> <span class="pre">:</span> <span class="pre">bool),</span> <span class="pre">(c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.</span></code> ist kurz für <code class="docutils literal notranslate"><span class="pre">(i</span> <span class="pre">:</span> <span class="pre">int),</span> <span class="pre">((b</span> <span class="pre">:</span> <span class="pre">bool),</span> <span class="pre">((c</span>
<span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.))</span></code>, usw.</li>
</ul>
<p>Das Überschatten wird klarer, wenn wir uns die Typenregeln anschauen, die das
Nachschlagen (lookup) in der Typenumgebung beschreiben.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>LOOKUP_FOUND -------------------
             (x : t), G |- x : t

                        G |- x : t
LOOKUP_NOT_FOUND_YET ----------------------- wo x und x&#39; verschieden sind.
                     (x&#39; : t&#39;), G |- x : t
</pre></div>
</div>
<p>In Worten:</p>
<ul class="simple">
<li>für einen beliebigen Namen <code class="docutils literal notranslate"><span class="pre">x</span></code>, einen beliebigen Typen <code class="docutils literal notranslate"><span class="pre">t</span></code> und eine beliebige
Typenumgebung <code class="docutils literal notranslate"><span class="pre">G</span></code> hat <code class="docutils literal notranslate"><span class="pre">x</span></code> den Typen <code class="docutils literal notranslate"><span class="pre">t</span></code> in der Typenumgebung <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">:</span> <span class="pre">t),</span> <span class="pre">G</span></code>;
und</li>
<li>für eine beliebige Typenumgebung <code class="docutils literal notranslate"><span class="pre">G</span></code>, einen beliebigen Namen <code class="docutils literal notranslate"><span class="pre">x</span></code>, einen
beliebigen Typen <code class="docutils literal notranslate"><span class="pre">t</span></code>, einen beliebigen Namen <code class="docutils literal notranslate"><span class="pre">x'</span></code>, der nicht der gleiche ist
wie <code class="docutils literal notranslate"><span class="pre">x</span></code> und einen beliebigen Typen <code class="docutils literal notranslate"><span class="pre">t'</span></code>: Wenn <code class="docutils literal notranslate"><span class="pre">x</span></code> in der Typenumgebung <code class="docutils literal notranslate"><span class="pre">G</span></code>
den Typen <code class="docutils literal notranslate"><span class="pre">t</span></code> hat, dann hat es denselben Typen <code class="docutils literal notranslate"><span class="pre">t</span></code>, wenn <code class="docutils literal notranslate"><span class="pre">G</span></code> durch die
Bindung <code class="docutils literal notranslate"><span class="pre">x'</span> <span class="pre">:</span> <span class="pre">t'</span></code> erweitert wird.</li>
</ul>
<p>In anderen Worten:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">x</span></code> hat immer den Typen <code class="docutils literal notranslate"><span class="pre">t</span></code> in einer Typenumgebung, die mit <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">:</span> <span class="pre">t)</span></code>
anfängt;</li>
<li><code class="docutils literal notranslate"><span class="pre">x</span></code> hat den Typen <code class="docutils literal notranslate"><span class="pre">t</span></code> in einer Typenumgebung, die mit <code class="docutils literal notranslate"><span class="pre">(x'</span> <span class="pre">:</span> <span class="pre">t')</span></code> anfängt und
mit <code class="docutils literal notranslate"><span class="pre">G</span></code> fortsetzt, wannimmer <code class="docutils literal notranslate"><span class="pre">x'</span></code> und <code class="docutils literal notranslate"><span class="pre">x</span></code> unterschiedliche Namen sind und
<code class="docutils literal notranslate"><span class="pre">x</span></code> in der Typenumgebung <code class="docutils literal notranslate"><span class="pre">G</span></code> den Typen <code class="docutils literal notranslate"><span class="pre">t</span></code> hat.</li>
</ul>
<p>Wir benutzen diese Regeln um Namen in einer Typenumgebung nachzuschlagen. Also zum
Beispiel:</p>
<ol class="loweralpha simple">
<li>einen beliebigen Namen in der leeren Typenumgebung <code class="docutils literal notranslate"><span class="pre">.</span></code> nachzuschlagen ist
undefiniert (und ruft einen Fehler hervor),</li>
<li><code class="docutils literal notranslate"><span class="pre">i</span></code> in der Typenumgebung <code class="docutils literal notranslate"><span class="pre">(i</span> <span class="pre">:</span> <span class="pre">int),</span> <span class="pre">(b</span> <span class="pre">:</span> <span class="pre">bool),</span> <span class="pre">(c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.</span></code> nachzuschlagen
ergibt <code class="docutils literal notranslate"><span class="pre">int</span></code>,</li>
<li><code class="docutils literal notranslate"><span class="pre">b</span></code> in der Typenumgebung <code class="docutils literal notranslate"><span class="pre">(i</span> <span class="pre">:</span> <span class="pre">int),</span> <span class="pre">(b</span> <span class="pre">:</span> <span class="pre">bool),</span> <span class="pre">(c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.</span></code> nachzuschlagen
ergibt <code class="docutils literal notranslate"><span class="pre">bool</span></code>,</li>
<li><code class="docutils literal notranslate"><span class="pre">c</span></code> in der Typenumgebung <code class="docutils literal notranslate"><span class="pre">(i</span> <span class="pre">:</span> <span class="pre">int),</span> <span class="pre">(b</span> <span class="pre">:</span> <span class="pre">bool),</span> <span class="pre">(c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.</span></code> nachzuschlagen
ergibt <code class="docutils literal notranslate"><span class="pre">char</span></code>,</li>
<li><code class="docutils literal notranslate"><span class="pre">x</span></code> in der Typenumgebung <code class="docutils literal notranslate"><span class="pre">(i</span> <span class="pre">:</span> <span class="pre">int),</span> <span class="pre">(b</span> <span class="pre">:</span> <span class="pre">bool),</span> <span class="pre">(c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.</span></code> nachzuschlagen
ist undefiniert und ruft einen Fehler hervor,</li>
<li><code class="docutils literal notranslate"><span class="pre">x</span></code> in der Typenumgebung <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">:</span> <span class="pre">int),</span> <span class="pre">(x</span> <span class="pre">:</span> <span class="pre">bool),</span> <span class="pre">(x</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.</span></code> nachzuschlagen
ergibt <code class="docutils literal notranslate"><span class="pre">int</span></code>.</li>
</ol>
<p>Im letzten Fall überschattet die letzte Bindung von <code class="docutils literal notranslate"><span class="pre">x</span></code> die beiden vorigen
Bindungen.</p>
</div>
<div class="section" id="ubung-25">
<h2>Übung 25<a class="headerlink" href="#ubung-25" title="Link zu dieser Überschrift">¶</a></h2>
<p>Überzeuge dich von den obigen Beispielen indem du die jeweiligen Beweisbäume
aufzeichnest.</p>
</div>
<div class="section" id="teilweise-losung-fur-ubung-25">
<h2>Teilweise Lösung für Übung 25<a class="headerlink" href="#teilweise-losung-fur-ubung-25" title="Link zu dieser Überschrift">¶</a></h2>
<ol class="loweralpha">
<li><p class="first">Nehmen wir den Namen <code class="docutils literal notranslate"><span class="pre">x</span></code> und versuchen wir, diesen Namen in der leeren
Typenumgebung <code class="docutils literal notranslate"><span class="pre">.</span></code> nachzuschlagen. Die Wurzel des Baumes ist folglich:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>. |- x : ehm
</pre></div>
</div>
<p>für einen bisher noch unbekannten Typen <code class="docutils literal notranslate"><span class="pre">ehm</span></code>.</p>
<p>Wir könenn weder die Regel <code class="docutils literal notranslate"><span class="pre">LOOKUP_FOUND</span></code> noch die Regel
<code class="docutils literal notranslate"><span class="pre">LOOKUP_NOT_FOUND_YET</span></code> anwenden. Also können wir keinen Beweisbaum konstruieren
und somit auch keinen Typen für <code class="docutils literal notranslate"><span class="pre">x</span></code> finden. Der Typ von <code class="docutils literal notranslate"><span class="pre">x</span></code> ist also
undefiniert.</p>
</li>
<li><p class="first">Versuchen wir <code class="docutils literal notranslate"><span class="pre">i</span></code> in der Typenumgebung <code class="docutils literal notranslate"><span class="pre">(i</span> <span class="pre">:</span> <span class="pre">int),</span> <span class="pre">(b</span> <span class="pre">:</span> <span class="pre">bool),</span> <span class="pre">(c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.</span></code>
nachzuschlagen. Die Wurzel des Baumes lautet:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(i : int), (b : bool), (c : char), . |- i : ehm
</pre></div>
</div>
<p>für einen bisher unbekannten Typen <code class="docutils literal notranslate"><span class="pre">ehm</span></code>.</p>
<p>Wir können (nur) die Regel <code class="docutils literal notranslate"><span class="pre">LOOKUP_FOUND</span></code> verwenden, wo <code class="docutils literal notranslate"><span class="pre">x</span></code> mit <code class="docutils literal notranslate"><span class="pre">i</span></code> ersetzt
wird, <code class="docutils literal notranslate"><span class="pre">t</span></code> mit <code class="docutils literal notranslate"><span class="pre">int</span></code>, und <code class="docutils literal notranslate"><span class="pre">G</span></code> mit <code class="docutils literal notranslate"><span class="pre">(b</span> <span class="pre">:</span> <span class="pre">bool),</span> <span class="pre">(c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.</span></code>. Auf der
rechten Seite des <code class="docutils literal notranslate"><span class="pre">|-</span></code> ersetzen wir wieder <code class="docutils literal notranslate"><span class="pre">x</span></code> mit <code class="docutils literal notranslate"><span class="pre">i</span></code> und <code class="docutils literal notranslate"><span class="pre">t</span></code> mit
<code class="docutils literal notranslate"><span class="pre">ehm</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>LOOKUP_FOUND -------------------------------------------------
              (i : int), (b : bool), (c : char), . |- i : ehm
</pre></div>
</div>
<p>Da in diesem Beweisbaum <code class="docutils literal notranslate"><span class="pre">t</span></code> einmal mit <code class="docutils literal notranslate"><span class="pre">int</span></code> und einmal mit <code class="docutils literal notranslate"><span class="pre">ehm</span></code> ersetzt
ist, haben wir nun herausgefunden, dass der bisher unbekannte Typ <code class="docutils literal notranslate"><span class="pre">ehm</span></code> in
Wirklichkeit <code class="docutils literal notranslate"><span class="pre">int</span></code> sein muss. Der fertige Beweisbaum lautet also:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>LOOKUP_FOUND -------------------------------------------------
               (i : int), (b : bool), (c : char), . |- i : int
</pre></div>
</div>
<p>Die Existenz dieses Baumes Beweist, dass in der Typenumgebung <code class="docutils literal notranslate"><span class="pre">(i</span> <span class="pre">:</span> <span class="pre">int),</span> <span class="pre">(b</span> <span class="pre">:</span>
<span class="pre">bool),</span> <span class="pre">(c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.</span></code> das Nachschlagen des Namens <code class="docutils literal notranslate"><span class="pre">i</span></code> den Typen <code class="docutils literal notranslate"><span class="pre">int</span></code>
ergibt.</p>
</li>
<li><p class="first">Versuchen wir <code class="docutils literal notranslate"><span class="pre">b</span></code> in der Typenumgebung <code class="docutils literal notranslate"><span class="pre">(i</span> <span class="pre">:</span> <span class="pre">int),</span> <span class="pre">(b</span> <span class="pre">:</span> <span class="pre">bool),</span> <span class="pre">(c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.</span></code>
nachzuschlagen. Die Wurzel des Baumes lautet:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(i : int), (b : bool), (c : char), . |- b : ehm
</pre></div>
</div>
<p>für einen bisher unbekannten Typen <code class="docutils literal notranslate"><span class="pre">ehm</span></code>.</p>
<p>Wir können hier (nur) die Regel <code class="docutils literal notranslate"><span class="pre">LOOKUP_NOT_FOUND_YET</span></code> anwenden, wo <code class="docutils literal notranslate"><span class="pre">x'</span></code> mit
<code class="docutils literal notranslate"><span class="pre">i</span></code> ersetzt wird, <code class="docutils literal notranslate"><span class="pre">t'</span></code> mit <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">G</span></code> mit <code class="docutils literal notranslate"><span class="pre">(b</span> <span class="pre">:</span> <span class="pre">bool),</span> <span class="pre">(c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.</span></code>,
<code class="docutils literal notranslate"><span class="pre">x</span></code> mit <code class="docutils literal notranslate"><span class="pre">b</span></code> und <code class="docutils literal notranslate"><span class="pre">t</span></code> mit <code class="docutils literal notranslate"><span class="pre">ehm</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>                     (b : bool), (c : char), . |- b : ehm
LOOKUP_NOT_FOUND_YET -----------------------------------------------
                     (i : int), (b : bool), (c : char), . |- b : ehm
</pre></div>
</div>
<p>Nun können wir (nur) die Regel <code class="docutils literal notranslate"><span class="pre">LOOKUP_FOUND</span></code> anwenden, wo <code class="docutils literal notranslate"><span class="pre">x</span></code> mit <code class="docutils literal notranslate"><span class="pre">b</span></code>
ersetzt wird, <code class="docutils literal notranslate"><span class="pre">t</span></code> mit <code class="docutils literal notranslate"><span class="pre">bool</span></code>, <code class="docutils literal notranslate"><span class="pre">G</span></code> mit <code class="docutils literal notranslate"><span class="pre">(c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code> mit <code class="docutils literal notranslate"><span class="pre">b</span></code> und
<code class="docutils literal notranslate"><span class="pre">t</span></code> mit <code class="docutils literal notranslate"><span class="pre">ehm</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>        LOOKUP_FOUND ------------------------------------
                     (b : bool), (c : char), . |- b : ehm
LOOKUP_NOT_FOUND_YET -----------------------------------------------
                     (i : int), (b : bool), (c : char), . |- b : ehm
</pre></div>
</div>
<p>Da wir in der Anwendung von <code class="docutils literal notranslate"><span class="pre">LOOKUP_FOUND</span></code> <code class="docutils literal notranslate"><span class="pre">t</span></code> im einen Fall mit <code class="docutils literal notranslate"><span class="pre">bool</span></code> und
im anderen Fall mit <code class="docutils literal notranslate"><span class="pre">ehm</span></code> ersetzt haben, wissen wir nun, dass der bisher
unbekannte Typ <code class="docutils literal notranslate"><span class="pre">ehm</span></code> <code class="docutils literal notranslate"><span class="pre">bool</span></code> sein muss.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>        LOOKUP_FOUND ------------------------------------
                     (b : bool), (c : char), . |- b : bool
LOOKUP_NOT_FOUND_YET -----------------------------------------------
                     (i : int), (b : bool), (c : char), . |- b : bool
</pre></div>
</div>
<p>Die Existenz dieses Baumes Beweist, dass in der Typenumgebung <code class="docutils literal notranslate"><span class="pre">(i</span> <span class="pre">:</span> <span class="pre">int),</span> <span class="pre">(b</span> <span class="pre">:</span>
<span class="pre">bool),</span> <span class="pre">(c</span> <span class="pre">:</span> <span class="pre">char),</span> <span class="pre">.</span></code> das Nachschlagen des Namens <code class="docutils literal notranslate"><span class="pre">b</span></code> den Typen <code class="docutils literal notranslate"><span class="pre">bool</span></code>
ergibt.</p>
</li>
</ol>
<p>d.-f. Konstruiere diese Bäume selbst.</p>
</div>
<div class="section" id="zwischenspiel-uber-umgebungen-und-zwiebeln">
<h2>Zwischenspiel über Umgebungen und Zwiebeln<a class="headerlink" href="#zwischenspiel-uber-umgebungen-und-zwiebeln" title="Link zu dieser Überschrift">¶</a></h2>
<p><strong>Alfrothul:</strong> Erklär mir bitte nochmal, warum jetzt eine Umgebung aufgebaut ist wie
eine Zwiebel…?</p>
<p><strong>Brynja:</strong> Eigentlich ganz logisch. Eine Zwiebel können wir auch beschreiben wie
eine Umgebung:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;zwiebel&gt;  ::= ^ | (&lt;zwiebel&gt;)

&lt;umgebung&gt; ::= . |(&lt;name&gt; : &lt;typ&gt;), &lt;umgebung&gt;
</pre></div>
</div>
<p>Eine leere Umgebung ist wie der Keim, <code class="docutils literal notranslate"><span class="pre">^</span></code> in der Mitte einer Zwiebel: es ist nichts weiter
innen drin. Und wenn wir eine Zwiebel haben, können wir eine neue Zwiebel
konstruieren indem wir noch eine Lage drum herum wachsen lassen. Ich habe mir hier
die Freiheit genommen, jede Schicht mit einem Paar Klammern zu zeigen; sieht ja auch
aus wie eine Zwiebel. Also wir haben eine Zwiebel, zum Beispiel <code class="docutils literal notranslate"><span class="pre">(((^)))</span></code> und
können dann eine neue machen: <code class="docutils literal notranslate"><span class="pre">((((^))))</span></code></p>
<p>Ebenso konstruieren wir eine neue Umgebung indem wir eine bereits vorhandene nehmen
und noch eine Bindung hinzufügen. Also wenn wir die Umgebung <code class="docutils literal notranslate"><span class="pre">G</span></code> haben, können wir
eine neue machen, indem wir die Bindung von <code class="docutils literal notranslate"><span class="pre">x</span></code> zum Typen <code class="docutils literal notranslate"><span class="pre">t</span></code> hinzufügen: <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">:</span>
<span class="pre">t),</span> <span class="pre">G</span></code>.</p>
<p><strong>Alfrothul:</strong> Ok…</p>
<p><strong>Brynja:</strong> Jetzt stell dir vor, dass auf jede Schicht der Zwiebel ein Name gedruckt
ist.</p>
<p><strong>Alfrothul:</strong> Ok?</p>
<p><strong>Brynja:</strong> Jetzt gebe ich dir eine Zwiebel und frage dich, ob dein name auf eine der
Schichten gedruckt ist. Was musst du tun um diese Frage zu beantworten?</p>
<p><strong>Alfrothul:</strong> Ich schätze, ich muss die Schichten von der Zwiebel eine nach der
anderen abpulen und drauf gucken.</p>
<p><strong>Brynja:</strong> Genau. Und was, wenn du keine Schichten mehr hast, sondern nur den Keim?</p>
<p><strong>Alfrothul:</strong> Dann weiß ich, dass mein Name auf keiner der Schichten gestanden hat.</p>
<p><strong>Brynja:</strong> Eben. Wie in der leeren Umgebung.</p>
<p><strong>Sigrid (von der Seite):</strong> Und was, wenn die Zwiebel unendlich ist?</p>
<p><strong>Alfrothul:</strong> Unendlich? Das wüsste ich aber, wenn es so eine Zwiebel gibt.</p>
<p><strong>Brynja:</strong> Das kann sie auch gar nicht sein, sie ist schließlich konstruiert
worden. Beziehungsweise, wenn wir von der Metapher absehen, dann ist sie
gewachsen. Von innen nach außen. Das heißt, irgendwann müssen wir zum Keim kommen.</p>
<p><strong>Sigrid:</strong> Hm… und das gilt auch für Umgebungen, nehme ich an?</p>
<p><strong>Brynja:</strong> Ja, genau. Jedes mal wenn wir einen neuen Namen binden, erweitern wir die
Umgebung um eine Schicht. Und weil wir wissen, dass wir kein unendliches Programm
geschrieben haben, wissen wir auch, dass die Umgebung nicht unendlich sein kann.</p>
<p><strong>Alfrothul:</strong> Ich glaube, jetzt habe ich es kapiert. Aber wie machen wir das denn
überhaupt mit dem binden? Wir haben doch bisher nur gesehen, dass wir Namen schreiben
können, aber nicht wie wir Namen in OCaml binden können.</p>
<p><strong>Brynja:</strong> Vielleicht können wir das ja gar nicht…? Vielleicht haben wir nur die
schon definierten Namen?</p>
<p><strong>Sigrid:</strong> Schon definierte Namen?</p>
<p><strong>Brynja:</strong> Ja. Erinnert ihr euch noch an Woche-01 wo wir über <code class="docutils literal notranslate"><span class="pre">min_int</span></code> und
<code class="docutils literal notranslate"><span class="pre">max_int</span></code> gelernt haben?</p>
<p><strong>Sigrid und Alfrothul:</strong> Ja…?</p>
<p><strong>Brynja:</strong> Das müssen doch Namen sein. Die passen jedenfalls zu keinem anderen
Ausdruck, den wir bisher gelernt haben.</p>
<p><strong>Mimer:</strong> Stimmt genau. Und diese vordefinierten Namen können uns noch etwas anderes
zeigen. Ihr habt ja schon Typenumgebungen gesehen, aber zu jedem Namen gehört ja auch
ein Wert. Es gibt also auch Wertumgebungen. Die funktionieren genau so wie die
Typenumgebungen, nur dass sie für jeden Namen einen Wert speichern statt eines
Typen.</p>
<p><strong>Brynja:</strong> Das heißt irgendwo in OCaml ist eine Wertumgebung schon definiert, und
auf einer der Schichten steht:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(min_int : -4611686018427387904), (max_int : 4611686018427387903), G
</pre></div>
</div>
<p>wenn wir die restliche Werteumgebung <code class="docutils literal notranslate"><span class="pre">G</span></code> nennen.</p>
<p><strong>Mimer:</strong> Gut erkannt. Wir würden in diesem Fall wohl eher ein <code class="docutils literal notranslate"><span class="pre">=</span></code> benutzen statt
eines <code class="docutils literal notranslate"><span class="pre">:</span></code>, aber das Prinzip ist das gleiche.</p>
<p><strong>Alfrothul:</strong> Also <code class="docutils literal notranslate"><span class="pre">=</span></code> für Werte und <code class="docutils literal notranslate"><span class="pre">:</span></code> für Typen?</p>
<p><strong>Mimer:</strong> Genau.</p>
<p><strong>Sigrid:</strong> Aber was ist denn jetzt mit der Frage von vorhin? Können wir neue Namen
definieren? Und wenn ja, wie?</p>
<p><strong>Mimer:</strong> Einfach weiterlesen. Das kommt im nächsten Abschnitt.</p>
<blockquote class="epigraph">
<div><div class="line-block">
<div class="line">Pile on many more layers</div>
<div class="line">and I’ll be joining you there.</div>
</div>
<p class="attribution">&mdash;<a class="reference external" href="https://en.wikipedia.org/wiki/Shine_On_You_Crazy_Diamond">Pink Floyd</a></p>
</div></blockquote>
</div>
<div class="section" id="globale-variablen-deklarieren">
<h2>Globale Variablen deklarieren<a class="headerlink" href="#globale-variablen-deklarieren" title="Link zu dieser Überschrift">¶</a></h2>
<p>Natürlich sind Namen nicht sehr hilfreich, wenn man keine neuen definieren kann. In
OCaml haben wir die Möglichkeit, namen im Toplevel zu deklarieren und das Ergebnis
des Evaluierens eines Ausdruckes sowie den dazugehörigen Typen zu diesem Namen zu
binden:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;toplevel-expression&gt; ::= &lt;expression&gt;
                        | let &lt;formal&gt; = &lt;definiens&gt;

&lt;formal&gt;              ::= &lt;name&gt;

&lt;definiens&gt;           ::= &lt;expression&gt;
</pre></div>
</div>
<p>Das Binden einer Variablen erweitert OCamls Typenumgebung und Werteumgebung; nach dem
Binden können wir in folgenden Interaktionen mit der Toplevel-Loop auf die Variable
zugreifen. Wenn wir das tun, schlägt OCaml in seinen Umgebungen nach um den Typen und
den Wert zu finden.</p>
<p>Nehmen wir einen frisch gestarteten OCaml-Prozess.</p>
<ul>
<li><p class="first">zuerst bedeutet <code class="docutils literal notranslate"><span class="pre">x</span></code> gar nichts:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># x;;
Error: Unbound value x
#
</pre></div>
</div>
<p>daher findet OCaml auch nichts, wenn es in seiner ursprünglichen Typenumgebung
(nennen wir sie <code class="docutils literal notranslate"><span class="pre">Gt</span></code>) und Werteumgebung (<code class="docutils literal notranslate"><span class="pre">Gw</span></code>) nachschaut und druckt einen
Fehler;</p>
</li>
<li><p class="first">also binden wir <code class="docutils literal notranslate"><span class="pre">x</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># let x = 42;;
val x : int = 42
#
</pre></div>
</div>
<p>Wer aufgepasst hat, kann sich die neuen Umgebungen herleiten. Die Typenumgebung ist
nun <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">:</span> <span class="pre">int),</span> <span class="pre">Gt</span></code> und die Werteumgebung ist <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">:</span> <span class="pre">42),</span> <span class="pre">Gw</span></code>.</p>
</li>
<li><p class="first">Jetzt können wir <code class="docutils literal notranslate"><span class="pre">x</span></code> benutzen um den unter diesem Namen gespeicherten Wert zurück
zu bekommen:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># x;;
- : int = 42
#
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="ubung-26">
<h2>Übung 26<a class="headerlink" href="#ubung-26" title="Link zu dieser Überschrift">¶</a></h2>
<p>Führe die obige Interaktion in OCaml durch.</p>
<p>Danach gib die folgenden Schritte in OCaml ein:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">100;;</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">&quot;abracadabra&quot;;;</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">say</span> <span class="pre">=</span> <span class="pre">if</span> <span class="pre">1</span> <span class="pre">then</span> <span class="pre">&quot;what&quot;</span> <span class="pre">else</span> <span class="pre">&quot;?&quot;</span></code></li>
</ul>
<p>Schriebe für jeden Schritt auf, wie sich die Typenumgebung und die Werteumgebung
danach verändern.</p>
<p>Der letzte Schritt ruft einen Fehler hervor; finde heraus, ob die Variable <code class="docutils literal notranslate"><span class="pre">say</span></code>
trotzdem definiert wurde. Warum glaubst du, ist das der Fall?</p>
</div>
<div class="section" id="mehrere-globale-variablen-auf-einmal-deklarieren">
<h2>Mehrere globale Variablen auf einmal deklarieren<a class="headerlink" href="#mehrere-globale-variablen-auf-einmal-deklarieren" title="Link zu dieser Überschrift">¶</a></h2>
<p>Wir haben in OCaml auch die Möglichkeit mehrere (verschiedene) Variablen in einer
einzigen Eingabe zu binden. Die Grammatik dafür ist folgende:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;toplevel-expression&gt; ::= &lt;expression&gt;
                     | let &lt;formal&gt; = &lt;definiens&gt; {and &lt;formal&gt; = &lt;definiens&gt;}*
</pre></div>
</div>
<p>wo <code class="docutils literal notranslate"><span class="pre">{}*</span></code> bedeutet: wiederhole das in den Klammern gedruckte eine beliebige Anzahl
Male (null Mal ist auch zulässig).</p>
<p>Zum Beispiel:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># let x = 10 and y = 100;;
val x : int = 10
val y : int = 100
#
</pre></div>
</div>
<p>Das macht es uns leicht, die Werte von <code class="docutils literal notranslate"><span class="pre">x</span></code> und <code class="docutils literal notranslate"><span class="pre">y</span></code> zu tauschen:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># let x = y and y = x;;
val x : int = 100
val y : int = 10
#
</pre></div>
</div>
<p>(Gedankenfutter: Wie würden wir die Werte umtauschen, wenn wir nicht mehrere
Variablen zugleich binden könnten? Probiere deine Theorie gerne in OCaml aus.)</p>
<p>Wenn wir aber versuchen in einer Interaktion die gleiche Variable zweimal zu
deklarieren, wirft uns OCaml einen Fehler an den Kopf:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># let same = true and same = false;;
Error: Variable same is bound several times in this matching
#
</pre></div>
</div>
<p>Das ergibt auch Sinn. Die eine Bindung würde die andere schließlich überschatten und
da wir nicht auf halber Strecke durch diesen Befehl den ersten Wert benutzen können,
zwingt uns OCaml uns für einen Wert zu entscheiden.</p>
<p>(Gedankenfutter: Mit dieser Einschränkung, dass eine Variable nicht im selben Befehl
mehrmals gebunden werden kann, ist es wichtig in welcher Reihenfolge die Umgebungen
erweitert werden?)</p>
</div>
<div class="section" id="zwischenspiel-uber-die-wichtigkeit-der-reihenfolge-losung-zum-gedankenfutter">
<h2>Zwischenspiel über die Wichtigkeit der Reihenfolge (Lösung zum Gedankenfutter)<a class="headerlink" href="#zwischenspiel-uber-die-wichtigkeit-der-reihenfolge-losung-zum-gedankenfutter" title="Link zu dieser Überschrift">¶</a></h2>
<p><strong>Sigrid:</strong> Klar ist die Reihenfolge wichtig, sonst werden mit Pech irgendwelche
Variablen überschattet.</p>
<p><strong>Brynja:</strong> Aber wir wissen ja, dass alle Variablen, die wir in einer solchen
Interaktion binden unterschiedlich sind, sie können sich also gar nicht gegenseitig
überschatten.</p>
<p><strong>Alfrothul:</strong> Das heißt wir könnten mehrere verschiedene Umgebungen haben, die
trotzdem immer die gleichen Resultate haben?</p>
<p><strong>Brynja:</strong> Ja, genau. Das heißt in diesem Fall ist die Reihenfolge egal.</p>
<p><strong>Sigrid:</strong> Klingt ganz so wie die Äquivalenz von Funktionen, über die wir neulich
gesprochen haben. Da ist auch die Reihenfolge egal, solange das Ergebnis das gleiche
ist.</p>
<p><strong>Mimer:</strong> Gut bemerkt!</p>
</div>
<div class="section" id="version-of-variablen-und-funktionen">
<h2>Version of „variablen-und-funktionen“<a class="headerlink" href="#version-of-variablen-und-funktionen" title="Link zu dieser Überschrift">¶</a></h2>
<p>Erstellt [2023-01-29]</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Namen und Funktionen (der Rest der OCaml-Grammatik)</a><ul>
<li><a class="reference internal" href="#namen-und-typenumgebungen">Namen und Typenumgebungen</a></li>
<li><a class="reference internal" href="#ubung-25">Übung 25</a></li>
<li><a class="reference internal" href="#teilweise-losung-fur-ubung-25">Teilweise Lösung für Übung 25</a></li>
<li><a class="reference internal" href="#zwischenspiel-uber-umgebungen-und-zwiebeln">Zwischenspiel über Umgebungen und Zwiebeln</a></li>
<li><a class="reference internal" href="#globale-variablen-deklarieren">Globale Variablen deklarieren</a></li>
<li><a class="reference internal" href="#ubung-26">Übung 26</a></li>
<li><a class="reference internal" href="#mehrere-globale-variablen-auf-einmal-deklarieren">Mehrere globale Variablen auf einmal deklarieren</a></li>
<li><a class="reference internal" href="#zwischenspiel-uber-die-wichtigkeit-der-reihenfolge-losung-zum-gedankenfutter">Zwischenspiel über die Wichtigkeit der Reihenfolge (Lösung zum Gedankenfutter)</a></li>
<li><a class="reference internal" href="#version-of-variablen-und-funktionen">Version of „variablen-und-funktionen“</a></li>
</ul>
</li>
</ul>

  <h4>Vorheriges Thema</h4>
  <p class="topless"><a href="week-05-index.html"
                        title="vorheriges Kapitel">Lehrmaterial Woche-05</a></p>
  <h4>Nächstes Thema</h4>
  <p class="topless"><a href="../resources/dramatis_personae.html"
                        title="nächstes Kapitel">Dramatis Personae</a></p>
  <div role="note" aria-label="source link">
    <h3>Diese Seite</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/week-05/week-05-variablen-und-funktionen.rst.txt"
            rel="nofollow">Quellcode anzeigen</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Schnellsuche</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Los" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Stichwortverzeichnis"
             >Index</a></li>
        <li class="right" >
          <a href="../resources/dramatis_personae.html" title="Dramatis Personae"
             >weiter</a> |</li>
        <li class="right" >
          <a href="week-05-index.html" title="Lehrmaterial Woche-05"
             >zurück</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Einführung ins Programmieren 2022</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="week-05-index.html" >Lehrmaterial Woche-05</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2022, Kira Kutscher.
      Mit <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5 erstellt.
    </div>
  </body>
</html>